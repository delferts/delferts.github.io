[
["index.html", "Praktiskā biometrija 1. nodaļa. Ievads", " Praktiskā biometrija Didzis Elferts 2016-04-05   1. nodaļa. Ievads Šī grāmata ir mans mēģinājums samērā vieglā formā ar minimālu teorijas materiālu sniegt praktiskus padomus statistisko analīžu veikšanā biologiem. Tā kā uzsvars ir likts uz vārdu ‘’praktiski’’, tad lielāko grāmatas daļu sastāda piemēri tam, kā veikt katru no apskatītajiem statistiskajiem testiem. Plašāka teorētiskā pamatojuma iegūšanai noderēs citu autoru darbi. Nenoliedzami nopietnākais darbs latviešu valodā biometrijas jomā ir jāmin Liepa (1974) grāmata, angļu valodā tas būtu kāds no Sokala un Rohlfa izdevumiem, piemēram, Sokal and Rohlf (1995). Vieglākā formā nelielu teorētisko pamatojumu statistiskas pamatmetodēm latviešu valodā var meklēt Arhipova and Bāliņa (2006), tikai tajā piemēri būs no ekonomikas jomas. Par modernākām metodēm informāciju var meklēt, piemēram, Zuur, Ieno, and Smith (2007). Programma R ir izvēlēta kā rīks, ar kuru veikt prakstisko datu analīzi. Kāpēc tieši programma R? Pirmais arguments ir tas, ka šī programma ir bezmaksas, attiecīgi ir pieejama jebkuram lietotājam, kas izvēlēties izmantot šo grāmatu. Otrkārt, pamatdarbības programmā R notiek ar komandu rindām, kas lietotājam liek aizdomātas par darbībām, kuras viņš taisās veikt, nevis vienkārši kaut ko ņemts un klikšķināt. Trešais iemesls būtu tas, ka R šobrīd ir straujāk attīstošās statistikas programma, kas ļauj tajā veikt arī pašas jaunākās analīzes. Dotais materiāls ir mans pirmais mēģinājums uzrakstīt grāmatu par R, tāpēc tajā var ļoti daudz vēl pilnveidojamu lietu. Kā alternatīvus materiālus statistisko analīžu veikšanai programmā R var izmantot, piemēram, Verzani (2005), Everitt and Hothorn (2006) vai Maindonald and Braun (2010).  "],
["biometrija-un-datu-analize.html", "2. nodaļa. Biometrija un datu analīze 2.1 Kas ir biometrija? 2.2 Paraugkopa un ģenerālkopa 2.3 Hipotēžu pārbaude", " 2. nodaļa. Biometrija un datu analīze  2.1 Kas ir biometrija? Biometrijas jēdzienam ir vairāki skaidrojumi, bet šīs grāmatas ietvaros ar to sapratīs statistisko un matemātisko metožu pielietošanu bioloģisko datu analīzei. Vienkāršoti varētu teikt, ka biometrija ir statistika biologiem. Kā statistikas virzienu arī biometrijai var izškirt divus virzienus: aprakstošā statistika un secinošā statistika. Aprakstošā statistika iekļauj metodes, kas paredzētas informācijas par paraugkopu vai ģenerālkopu organizēšanai, grafiskai attēlošanai un apkopošanai. Secinošā statistika iekļauj metodes, kas izmanto paraugkopas informāciju, lai izdarītu secinājumus par visu ģenerālkopu.   2.2 Paraugkopa un ģenerālkopa Jebkurā eksperimentā vai pētījumā tiek izraudzīti objekti, kurus pētīt, piemēram, putnus, augus, konkrētas šūnas vai tikai to sastāvdaļas, vai arī kompleksi kā biotops. Katram no šiem objektiem pēta konkrētas pazīmes, piemēram, lidspalvu garums, hlorofila koncentrācija vai sugu skaits konkrētā biotopā. Pētījumam vienmēr iegūst nevis vienu konkrētu pazīmes vērtību (objektu), bet gan vairākas, lai būtu iespējams novērtēt variāciju šajās vērtības. Šīs daudzās vērtības var veidot ģenerālkopu vai paraugkopu. Ģenerālkopa jeb populācija sastāv no visām konkrētās pazīmes vērtībām, un tās lielums ir atkarīgs no pētījuma jautājuma. Piemēram, ja pētījuma mērķis ir noskaidrot kāds ir vidējais priežu garums Latvijā, tad ģenerālkopa būs visas priedes Latvijā. Ja jautājumu sašaurina līdz vidējam priežu garumam Dundagas novadā, tad arī ģenerālkopa būs šaurāka. Vairumā pētījumu nav iespējams aptvert visas iespējamās ģenerālkopas vērtības, tāpēc tiek izraudzīta tikai daļa no tās. Šo daļu no ģenerālkopas, kuru pēta, sauc par paraugkopu.   2.3 Hipotēžu pārbaude Veicot pētījumus, viens no uzdevumiem ir izdarīt secinājumus par to vai vērojamas atšķirības, saistības vai ietekme, piemēram, vai pastāv atšķirība starp augu vidējo garumu dažādos mēslošanas apstākļos, vai temperatūru pieaugums maina dzīvnieku uzvedību, utt. Viena no pieejām secinājumu izdarīšanai ir tā saucamā hipotēžu pārbaude. Pirms pētījuma veikšanas izvirza tā saucamo Nulles hipotēzi (\\(H_0\\)), kas tālāk tiek pārbaudīta jau pētījuma laikā. Nulles hipotēze parasti apgalvo, ka starp diviem lielumiem nav atšķirības vai, ka nav vērojama ietekme. Apzīmējums \\(H_0:X=Y\\) nozīmē, ka Nulles hipotēze apgalvo, ka rādītāji X un Y savā starpā neatšķiras jeb tie ir vienādi. Vienlaicīgi ar Nulles hipotēzi izvirza arī alternatīvo hipotēzi, kas tiek pieņemta, ja Nulles hipotēze nav spēkā. Gadījumā ar X un Y alternatīvā hipotēze būs $H_1:XY $. Ir skaidrs, ka ļoti reti X un Y tiešām būs identiski un gandrīz vienmēr būs kaut kāda atšķirība. Tāpēc statistiskajos testos, kurus balsta uz hipotēžu pārbaudi, ir pieņemts aprēķināt p-vērtības, kuru interpretācija ir dažāda. Viena no interpretācijām ir, ka p-vērtība norāda kāda ir iespējamība iegūt tik pat ekstrēmus datus (vai atšķirību rādītājos) kā novērotie, ja pieņem, ka Nulles hipotēze ir patiesa. Bioloģijā visbiežāk Nulles hipotēzi noraida un akceptē alternatīvo hipotēzi, ja p-vērtība ir mazāka par 0,05. Šo līmeni sauc par būtiskuma līmeni un apzīmē ar \\(\\alpha\\). Vēl pieņemtie būtiskuma līmeņi ir 0,01 un 0,001. Attiecīgi no būtiskuma līmeņa atvasina citu rādītāju, kas ir ticamības līmenis (P) un to aprēķina kā \\(P=1-\\alpha\\). Parādot rezultātus publikācijās vai kādos citos darbus vēlams būtu norādīt tieši kādair bijusi p-vērtība, nevis vienkārši rakstīt, piemēram, p&lt;0,05. Noraidot Nulles hipotēzi, mēs varam apgalvot, ka pastāv, piemēram, statistiski būtiska atšķirība starp lielumiem X un Y, bet tas automātiski nenozīmē, ka šī atšķirība ir arī bioloģiski būtiska, piemēram, pie liela paraugkopas apjoma izmaiņas garumā par 1% arī var būt statistiski būtiskas, bet vai varam apgalvot ka tās ir bioloģiski būtiskas. Nulles hipotēzes nenoraidīšana vēl nenozīmē, ka tā ir patiesa, jo, iespējams, paraugkopas apjoms bija pārāk mazs, sevišķi, ja p-vērtības ir tuvu būtiskuma līmeņa vērtībām. Vēl attiecībā uz hipotēžu noraidīšanu un akceptēšanu ir jāpiemin 1. un 2. tipa kļūdas. 1. tipa kļūda rodas tad, ja Nulles hipotēze tiek noraidīta, kaut arī tā ir patiesa. Šāda iespējamība ir vienāda ar izvēlēto būtiskuma līmeni. 2. tipa kļūda rodas tad, ja Nulles hipotēze tiek akceptēta, ka arī tā nav patiesa. Veicot eksperimentus un pētījumus ir jāņem vērā šādas iespējamības un jācenšās tās kaut daļēji kontrolēt. Jāpiemin gan, ka hipotēžu pārbaudes teorija un balstīšanās uz p-vērtībām pēdējo desmit līdz divdesmit gadu laikā ir ievērojami apšaubīta un ir ieteikumi izmantot citas pieejas, piemēram, secinājumus balstīt uz ticamības intervāliem, vai arī izmantot modeļu izvēles kritērijus, Beijesa (Bayesian) metodes. Ieskatu problēmās un alternatīvās ar hipotēžu pārbaudi var gūt Johnson (1999) un Stephens et al. (2005) rakstos. Šajā grāmatā izmantoti gan klasiskā hipotēžu pārbaudes metode, gan arī citas alternatīvas.   "],
["ievads-darba-ar-programmu-r.html", "3. nodaļa. Ievads darbā ar programmu R 3.1 Kas ir programma R un kā uzsākt darbu? 3.2 Darbs ar R", " 3. nodaļa. Ievads darbā ar programmu R  3.1 Kas ir programma R un kā uzsākt darbu?  3.1.1 R vide R ir vienlaicīgi datorprogramma un valoda (veidojusies no programmēšanas valodas ‘S’), kas paredzēta datu apstrādei, aprēķiniem un grafiku veidošanai. Visi piemēri šajā grāmatā ir veidoti programmas R versijā 3.2.2. (R Core Team 2012). R priekšrocības ir:  tā ir atvērtā koda programma, kas nepārtraukti tiek papildināta un uzlabota, un šajā darbā ir iesaistīti tūkstošiem cilvēku visā pasaulē} R ir izmantojams uz dažādām datoru platformām: Unix, Linux, Windows, MacOS; lietotājam ir dota iespēja kontrolēt visus parametrus veicot dažādus aprēķinus; R ir ļoti labas grafiskās iespējas, kas ļauj veidot augstas kvalitātes grafikus.    3.1.2 R instalācija un papildus paketes Lai instalētu programmu R, ir nepieciešams lejupielādēt Jūsu izmantotajai platformai atbilstošo R instalācijas failu no CRAN servera. Serveru adreses, kā arī citu informāciju var atrast mājas lapā http://www.R-project.org Pirmkārt, ir jāuzinstalē pamatfails R-base. Programma R ir veidota tā, ka R-base satur tikai daļu no nepieciešamajām funkcijām, pārējās ir pieejamas papildus paketēs. Tās var uzinstalēt trīs veidos:  izmantojot funkciju install.packages() un norādot instalējamās paketes nosaukumu. programmā R komandu rindā izvēlas Packages/Install package(s)... Tad izvēlas tuvāko serveri un paketes, kuras nepieciešams instalēt. ja paketes pirms tam tika lejupielādētas datorā, tad izvēlas opciju Packages/Install package(s) from local zip files...  Ja kāda no paketēm ir nepieciešama konkrētajā darba sesijā, tad pirms lietošanas tā ir „jāpievieno” ar funkciju library(), kur iekavās norādīts nepieciešamās paketes nosaukums, piemēram: library(grid)   3.1.3 Palīdzības iegūšana Papildus informāciju un palīdzību darbam ar R var iegūt no dažādām pamācībām, kas brīvi pieejamas internetā. Par programmu R ir arī ļoti daudz grāmatu, no kurām nopietnākais darbs ir Crawley (2007). Ir pieejama arī R iekšējā palīdzībā. Ja nepieciešams iegūt palīdzību par kādu konkrētu funkciju, vieglākais veids ir izmantot help() funkciju, kurai iekavās norādīts otras funkcijas nosaukums, piemēram: help(plot) Otrs variants ir rakstīt ? zīmi pirms funkcijas nosaukuma. Jāņem vērā, ka šādā veidā ir iespējams meklēt palīdzību tikai par tām funkcijām, kuras atrodas konkrētajai darba sesijai pievienotajās paketēs. Ja nepieciešams meklēt funkciju visās instalētajās paketēs, tad jāizmanto divas ? zīmes. ??plot    3.2 Darbs ar R  3.2.1 Komandu veidošana R vidē visas komandas tiek rakstītas pēc &gt; zīmes (tā nav pašam jāraksta). Ja komandu rinda ir pārāk gara, tad pēc jebkura argumeta, vai arī pēc iekavām, komata, utt var spiest Enter taustiņu un turpināt pierakstu jaunā rindā. Šajā gadījumā automātiski parādīsies + zīme. Ja komanda tiek uzrakstīta pilnībā un nospiests Enter, šī komanda tiek izpildīta. Ja komanda neizpildās, bet parādās + zīme, tas nozīmē, ka komandas pierakstā ir kļūda un trūkst, piemēram, kādas iekavas. Komandu rindas galā var pievienot arī komentāru, pirms komentāra ir jāraksta # zīme. R vidē atstarpes starp dažādiem objektiem, iekavām tiek ignorētas, izņēmums ir kombinācija &lt;-, ar kuru objektiem piešķir noteiktu vērtību. Rakstot komandas ir būtiski ievērot lielo un mazo burtu izvietojumu, jo šajā gadījumā apzīmējums AA nebūs tas pats, kas aa.   3.2.2 Kalkulators Programmu R savā veidā var izmantot kā kalkulatoru, ar kura palīdzību ir iespējams veikt dažādus aprēķinus. 4+7 ## [1] 11 log(8,2) ## [1] 3 exp(2) ## [1] 7.389056   3.2.3 Datu veidi R vidē pārsvarā lieto trīs veidu datus: skaitliskos (numeric), rakstu zīmes (character) un loģiskos (logical). Skaitliskie dati ir skaitļi, un tikai šāda veida objektus var izmantot, lai veiktu aprēķinus. Rakstu zīmju datus parasti izmanto, lai norādītu mainīgajiem nosaukumus, kā arī, lai veiktu datu grupēšanu. Loģiskajiem datiem var būt divas vērtības TRUE vai FALSE (jeb T un F).   3.2.4 Datu struktūras Četras galvenās datu struktūras R vidē: vektors (vector), matrice (matrix), saraksts (list) un datu tabula (data frame).  3.2.4.1 Vektors Vektors ir viendimensionāla datu struktūra, kas var sastāvēt tikai no viena tipa datiem –- skaitļiem vai rakstu zīmēm. Vektora garums nav ierobežots – tas var būt tikai vienu zīmi liels, vai arī sastāv no ļoti daudz zīmēm vai skaitļiem. Lai nodefinētu vektoru, kas sastāv tikai no vairāk kā viena mainīgā, jāraksta vēlamais objekta (vektora) nosaukums un aiz apzīmējuma &lt;- jāraksta funkcija c(), kurai iekavās norāda mainīgos: Rezultātā izveidotais objekts tiek saglabāts R atmiņā. Lai apskatītu izveidoto objektu, ir jāuzraksta tā nosaukums un jānospiež Enter. pirmais&lt;-c(1,5,7,4,8,10) pirmais ## [1]  1  5  7  4  8 10 otrais&lt;-c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;) otrais ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot;   3.2.4.2 Matrice Matrice ir divdimensionāla datu struktūra, kas līdzīgi vektoram var saturēt tikai viena tipa datus. Matrici var izveidot izmantojot trīs funkcijas: cbind(), rbind() vai matrix(). Funkcijā matrix() norāda visus matricē iekļaujamos elementus, kā arī norāda rindu skaitu (nrow) vai arī kolonnu skaitu (ncol); abus nevajag norādīt, jo, ja ir norādīts, piemēram, kolonnu skaits, tad rindu skaits tiks aprēķināts automātiski, ņemot vērā elementu skaitu matricē: tresais&lt;-matrix(1:15,ncol=3) tresais ##      [,1] [,2] [,3] ## [1,]    1    6   11 ## [2,]    2    7   12 ## [3,]    3    8   13 ## [4,]    4    9   14 ## [5,]    5   10   15 Funkciju cbind() izmanto, lai izveidotu matrici, tās elementus secīgi rakstot kolonnās (iekavās aiz funkcijas jānorāda elementi, kas atradīsies katrā no kolonnām), attiecīgi funkciju rbind() izmanto matrices veidošanai pa rindiņām. ceturtais&lt;-cbind(pirmais,otrais) ceturtais ##      pirmais otrais ## [1,] &quot;1&quot;     &quot;A&quot;    ## [2,] &quot;5&quot;     &quot;B&quot;    ## [3,] &quot;7&quot;     &quot;C&quot;    ## [4,] &quot;4&quot;     &quot;D&quot;    ## [5,] &quot;8&quot;     &quot;E&quot;    ## [6,] &quot;10&quot;    &quot;F&quot; \\subsubsection{Saraksts} Saraksts ir datu struktūras, kas var saturēt jebkuru citu datu struktūru, tai skaitā arī apakšsarakstus. Saraksts ir ļoti ērts, lai vienā objektā apvienu dimensionāli atšķirīgus elementus, piemēram, no vienas analīzes rezultātiem. Sarakstu veido ar funkciju list(). piektais&lt;-list(vekt1=pirmais,matr1=tresais,matr2=ceturtais) piektais ## $vekt1 ## [1]  1  5  7  4  8 10 ##  ## $matr1 ##      [,1] [,2] [,3] ## [1,]    1    6   11 ## [2,]    2    7   12 ## [3,]    3    8   13 ## [4,]    4    9   14 ## [5,]    5   10   15 ##  ## $matr2 ##      pirmais otrais ## [1,] &quot;1&quot;     &quot;A&quot;    ## [2,] &quot;5&quot;     &quot;B&quot;    ## [3,] &quot;7&quot;     &quot;C&quot;    ## [4,] &quot;4&quot;     &quot;D&quot;    ## [5,] &quot;8&quot;     &quot;E&quot;    ## [6,] &quot;10&quot;    &quot;F&quot;   3.2.4.3 Datu tabula Datu tabula ir divdimensionāla datu struktūra, kas var saturēt dažāda tipa datus atsevišķās kolonnās (visām kolonnām vienā datu tabulā ir jābūt ar vienādu garumu). Datu tabulu izveido ar funkciju data.frame(). Funkcijas iekavās norāda kolonnu nosaukumus, kā arī datus, kas būs katrā no kolonnām. Dati var būt kā atsevišķi vektori, kas izveidoti jau iepriekš, vai arī datus var ierakstīt pašā funkcijā: sestais&lt;-data.frame(pirmais,otrais) sestais ##   pirmais otrais ## 1       1      A ## 2       5      B ## 3       7      C ## 4       4      D ## 5       8      E ## 6      10      F septitais&lt;-data.frame(kol1=c(1,2,3,4),kol2=c(5,6,7,8)) septitais ##   kol1 kol2 ## 1    1    5 ## 2    2    6 ## 3    3    7 ## 4    4    8 Vēl datu tabulu var izveidot izmantojot datu tabulu veidotāju pašā programmā R. Šajā gadījumā no sākuma ar kādu Jums vēlamu nosaukumu ir jāizveido datu tabula ar funkciju data.frame(), kurai netiek norādīti nekādi papildus argumenti. Pēc tam jāizmanto funkcija fix(), kurai kā arguments jānorāda jaunās datu tabulas nosaukums. Rezultātā parādīsies datu tabulu veidošanas logs, kurā var ievadīt datus. Lai mainītu kolonnu nosaukumus, ir jāuzklikšķina uz tā - šajā brīdī ir iespējams arī norādīt vai dati būs skaitliski vai rakstu zīmes. Ir jāatceras, ka vienā kolonnā var atrasties tikai viena veida dati, kā arī, ka visu kolonnu garumiem ir jābūt vienādiem. jauna.tabula&lt;-data.frame() fix(jauna.tabula) Ar funkcijas fix() palīdzību ir iespējams labot arī citas jau esošās tabulas.    3.2.5 Datu importēšana R vidē ir iespējams importēt dažāda formāta datu failus (datu tabulas), piemēram, no programmām Excell, SPSS, SAS. Vienkāršākais veids ir izmantot .txt vai .csv failus. Lai importētu .txt failus, tiek izmantota funkcija read.table(), attiecīgi .csv failus var importēt ar funkcijām read.csv() un read.csv2(). Funkcijā norāda faila nosaukumu un ceļu uz to (file=). Ja pirmā tabulas rinda satur kolonnu nosaukumus, tad kā papildus arguments jānorāda header=TRUE. Vēl jānorāda skaitļu decimāldaļu atdalītājs (komats vai punkts), izmantojot papildus argumentu dec=&quot;.&quot;. Tā kā .txt failiem mēdz būt dažādi kolonnu atdalīšanas veidi, tad jānorāda atbilstošais, izmantojot papildus argumentu sep=, iespējamās vērtības ir &quot;\\t&quot; - tab delimited; &quot;,&quot;- kolonnu atdalītājs ir komats; &quot;;&quot; - kolonnu atdalītājs ir semikols. Pilno ceļu uz importējamo failu var nenorādīt, ja fails atrodas darba direktorijā (Working directory) (var nomainīt ar funkciju setwd(). dati&lt;-read.table(file=&quot;niedres.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) dati2&lt;-read.csv(file=&quot;niedres.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) dati3&lt;-read.csv2(file=&quot;niedres.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) dati[1:10,] ##    garums platums ## 1    31.6     2.5 ## 2    23.2     2.3 ## 3    39.2     2.1 ## 4    37.4     5.8 ## 5    21.1     2.2 ## 6    37.0     4.1 ## 7    24.7     3.5 ## 8    31.3     4.2 ## 9    37.4     2.5 ## 10   39.7     2.8 Pašā programmā R ir iekļautas daudzas datu tabulas, kas ir ļoti noderīgas, piemēram, lai izmēģinātu kādas funkcijas, vai arī sekotu līdzi piemēriem mācību materiāliem. Lai redzētu, kuras datu tabulas ir pieejamas konkrētajā darba sesijā (atkarīgs no pievienoto pakešu daudzuma), jāizmanto funkcija data(), pēc kā parādīsies jauns logs, kurā uzskaitītas pieejamās datu tabulas un to apraksts. Lai redzētu visas pieejamās datu tabulas, jāraksta data(package = .packages(all.available = TRUE)). data() data(package = .packages(all.available = TRUE)) Lai pievienotu darba sesijai kādu no šīm datu tabulām, jāizmanto funkcija data(), kurai iekavās norādīts datu tabulas nosaukums. Ja pakete, kurā atrodas šī datu tabula jau ir pievienota darba sesijai, tad papildus argumenti nav vajadzīgi, bet ja pakete nav pievienota, tad funkcijai ir jāliek klāt papildus arguments package=}. Pēc tam datu tabula ir pievienota darba sesijai ar tādu nosaukumu, kāds ir pašai datu tabulai. data(cars) data(cars, package = &quot;datasets&quot;) cars[1:10,] ##    speed dist ## 1      4    2 ## 2      4   10 ## 3      7    4 ## 4      7   22 ## 5      8   16 ## 6      9   10 ## 7     10   18 ## 8     10   26 ## 9     10   34 ## 10    11   17   3.2.6 Datu eksportēšana Datu eksportēšanu veic ar funkciju write.table(), kurā jānorāda objekts, kuru vēlas eksportēt (x=), izveidojamā faila nosaukums un saite uzto (file=), kolonnu atdalītājs (sep=), decimālatdalītājs (dec=) un vai rindu nosaukumus iekļaut (row.names=TRUE vai FALSE). write.table(x=dati,file=&quot;eksports.txt&quot;,row.names=FALSE,sep=&quot;\\t&quot;,dec=&quot;.&quot;)   3.2.7 Darbs ar datiem Ar funkcijas str() palīdzību ir iespējams apskatīt jebkura datu objekta struktūru, tajā ejošos datus un to veidu. Rezultāts ir atkarīgs no tā, kāda veida datu objekts tiek apskatīts. str(dati) ## &#39;data.frame&#39;:    50 obs. of  2 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ... str(sestais) ## &#39;data.frame&#39;:    6 obs. of  2 variables: ##  $ pirmais: num  1 5 7 4 8 10 ##  $ otrais : Factor w/ 6 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 2 3 4 5 6 str(piektais) ## List of 3 ##  $ vekt1: num [1:6] 1 5 7 4 8 10 ##  $ matr1: int [1:5, 1:3] 1 2 3 4 5 6 7 8 9 10 ... ##  $ matr2: chr [1:6, 1:2] &quot;1&quot; &quot;5&quot; &quot;7&quot; &quot;4&quot; ... ##   ..- attr(*, &quot;dimnames&quot;)=List of 2 ##   .. ..$ : NULL ##   .. ..$ : chr [1:2] &quot;pirmais&quot; &quot;otrais&quot; str(tresais) ##  int [1:5, 1:3] 1 2 3 4 5 6 7 8 9 10 ... str(otrais) ##  chr [1:6] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; Datu tabulu un matricu apskatīšanai noderīgas ir funkcijas head() un tail(), kas attiecīgi parāda datu objekta pirmās sešas un pēdējās sešas rindiņas. Rindiņu skaitu ir iespējams mainīt, norādot papildus argumentu n=. head(dati) ##   garums platums ## 1   31.6     2.5 ## 2   23.2     2.3 ## 3   39.2     2.1 ## 4   37.4     5.8 ## 5   21.1     2.2 ## 6   37.0     4.1 tail(dati) ##    garums platums ## 45   46.1     5.3 ## 46   29.1     3.5 ## 47   33.7     4.6 ## 48   43.1     3.7 ## 49   38.8     3.9 ## 50   46.9     5.4  3.2.7.1 Daļas no objekta atlasīšana Ja ir nepieciešams atlasīt tikai daļu no objekta, veids kā to darīt ir atkarīgs no objekta veida. Tā kā vektors ir viendimensionāla datu struktūra, tad vien elementa atlsīšanai aiz objekta nosaukuma ir jāliek kvadrtātiskās iekavas, kurās jānorāda atlasāma elementa kārta numurs. otrais[1] ## [1] &quot;A&quot; Vairāku vektora elementu alasīšanai kvadrātiskajās iekavās jāizmanto funkcija c(), kurā norāda atlasāmo elemntu kārtas numurus. otrais[c(1,4)] ## [1] &quot;A&quot; &quot;D&quot; Ja ir nepieciešams atlasīt visus elementu, izņemot kādu konkrētu elementu, tad ‘’nevēlamā’’ elementa kārtas numuru kvadrātiskajās iekavās norāda ar mīnus zīmi. otrais[-3] ## [1] &quot;A&quot; &quot;B&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; No matrices, kas ir divdimensionāla datu struktūra, konkrētu elementu var atlasīt kvadrātiskajās iekavās norādot divus skaitļus, kur pirmais nozīmē rindiņas numuru, bet otrais nozīmē kolonnas numuru. tresais[2,2] ## [1] 7 Ja kvadrātiskajās iekavās norāda tikai vienu skaitli, bet otra vietu atstāj tukšu, tad attiecīgi tiek atlasīta visa rindiņa, vai arī visa kolonna. tresais[1,] ## [1]  1  6 11 tresais[,2] ## [1]  6  7  8  9 10 Elementus no saraksta var atlasīt vairākos veidos, piemēram, rakstot objekta nosaukumu, tad $ zīmi un saraksta elementa nosaukumu. Otrs variants ir izmantot dubultās kvadrātiskās iekavas un norādīt saraksta elementa kārtas numuru. piektais$vekt1 ## [1]  1  5  7  4  8 10 piektais[[2]] ##      [,1] [,2] [,3] ## [1,]    1    6   11 ## [2,]    2    7   12 ## [3,]    3    8   13 ## [4,]    4    9   14 ## [5,]    5   10   15 Ar iepriekšējām divām metodēm no saraksta ir iespējams atlasīt tikai visu elementu. Ja ir nepieciešams atlasīt kaut ko no paša saraksta elementa, tad jāizmanto otras kvadrātiskās iekavas. piektais[[2]][1,] ## [1]  1  6 11 No datu tabulas visu kolonnu var atlasīt tās nosaukumu norādot ar $ zīmes vai arī pēdiņās ierakstot kvadrātiskajās iekavās. sestais$pirmais ## [1]  1  5  7  4  8 10 sestais[&quot;pirmais&quot;] ##   pirmais ## 1       1 ## 2       5 ## 3       7 ## 4       4 ## 5       8 ## 6      10 Viena elementa atlasīšanai ir jāizmanto tāds pats pieraksts kā matricai - kvadrātiskajās iekavās jānorāda divi skaitļis, kas apzīmē rindiņas un kolonnas numuru. sestais[5,1] ## [1] 8 Viena no programmas R specifikām ir tā, ka datu tabulām esošos kolonnu nosaukumus nav iespējams uzreiz izmantot kā mainīgos. Piemēram, ja uzrakstīsim mainīgo garums, kas atrodas pievienotājā datu tabulā dati, parādīsies paziņojums, ka tāda mainīgā nav. R ,veidojot datus tabulas un importējot failus ,katru no kolonnām neuztver kā atsevišķu objektu. garums    3.2.8 Darba vides sakārtošana Ja darba sesijā rada dažādus objektus, pievieno daudz paketes, ar laiku var rasties apjukums par to, kādi objekti šobrīd ir aktīvi. Ar funkcijas ls() palīdzību, ir iespējams iegūt sarakstu ar visiem objektiem, kas šobrīd ir aktīvi: ls() ##  [1] &quot;cars&quot;      &quot;ceturtais&quot; &quot;dati&quot;      &quot;dati2&quot;     &quot;dati3&quot;     ##  [6] &quot;niedres&quot;   &quot;otrais&quot;    &quot;piektais&quot;  &quot;pirmais&quot;   &quot;septitais&quot; ## [11] &quot;sestais&quot;   &quot;tresais&quot;   &quot;x&quot; Lai kādu no šiem objektiem noņemtu no darba sesijas, jāizmanto funkcija , kurai kā arguments jānorāda objekts, kuru vēlaties noņemt no darba sesijas. Šī metode gan attiecas tikai uz tiem objektiem, kurus esat radījuši paši, nevis uz datu tabulām, kas atrodas paketēs. rm(pirmais)    "],
["grafiskas-iespejas-programma-r.html", "4. nodaļa. Grafiskās iespējas programmā R 4.1 Pamatgrafiki 4.2 Dati grafiku veidošanai 4.3 Grafiku parametru noteikšana 4.4 Grafiku saglabāšana", " 4. nodaļa. Grafiskās iespējas programmā R Programmā R ir iespējams veidot ļoti augstas kvalitātes grafikus, kuriem ir iespējams definēt jebkuru no interesējošiem parametriem. Grafiku veidošanai ir pieejamas vairākas grafiskās sistēmas, no kurām populārās trīs ir:  Tradicionālie grafiki (Murrell 2006) Trellis jeb Lattice grafiki (Sarkar 2008) ggplot2 grafiki (Wicham 2009)  Šajā grāmatā apskatīti tikai tradicionālo grafiku veidošana.  4.1 Pamatgrafiki Grafikus līdzīgi kā jebkuras citas darbības programmā R veic ar komandu rindām. Ir pieejamas funkcijas, kas izveido jau nodefinētu grafika veidu, vai arī var izveidot grafiku izmantojot atsevišķas funkcijas dažādu parametru definēšanai. R specifika ir tā, ka, izveidojot grafiku, parādās grafiskais logs, kurā ir attēlots konkrētais grafiks. Ja tiek izsaukta jauna funkcija, kas arī veido grafiku, iepriekšējais grafiks tiek aizstāts. Ja ir nepieciešams, ka uz ekrāna vienlaicīgi ir redzami vairāki grafiki, tad pirms katra jauan grafika ir jāraksta funkcija windows() (Windows vidē) vai quartz() (MacOS vidē). Lai veidotu grafiku, ir nepieciešami dati. Šajā nodaļā kā piemērs izmantots datu fails niedres.txt, kas satur informāciju par 50 niedru lapu garumu un platumu. Ar funkciju read.table() fails tiek importēts, pēc tam funkciju str() apskatīta tā struktūra. niedres&lt;-read.table(file=&quot;niedres.txt&quot;,header=T,sep=&quot;\\t&quot;,dec=&quot;.&quot;) str(niedres) ## &#39;data.frame&#39;:    50 obs. of  2 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ...  4.1.1 plot() Visbiežāk pielietotā funkcija grafiku veidošanai ir plot(). Ja šajā funkcijā norāda vienu vai divas skaitļu rindas, tad tā veido izkliedes grafiku (scatterplot) (4.1 attēls). Šai funkcijai ir iespējams norādīt ļoti daudz papildus argumentus, kas maina izveidoto grafiku. Turklāt liekot šajā funkcijā atšķirīgus datus objektu, var iegūt ļoti atšķirīgu rezultātu. plot(niedres$platums)    Figure 4.1: Izkliedes grafika piemērs     4.1.2 boxplot() Funkcija boxplot() izveido Box-plot grafiku (4.2 attēls). Šai funkcijai var norādīt vienu datu rindu, kas satur skaitļus, vai arī divas datu rindas, kur vienā ir skaiļi, bet otrā ir apzīmējumi dalījuma līmeņiem. Otrajā gadījumā attsevišķš Box-plot grafiks tiks izveidots katram no dalījuma līmeņiem. boxplot(niedres$platums)    Figure 4.2: Box-plot grafika piemērs     4.1.3 hist() Ar funkcijas hist() palīdzību ir iespējams izveidot histogrammu datiem, kas vēl nav sagarupēti klasēs (izejas datiem) (4.3 attēls). Šajā funkcijā ir jānorāda tikai viena datu rinda, kuru ir nepieciešams attēlot. Ar papildus argumentiem ir iespējams mainīt to, cik daļās dati tiek dalīti. hist(niedres$platums)    Figure 4.3: Histogrammas piemērs     4.1.4 barplot() Funkcija barplot() veido slokšņu jeb stabiņu grafiku (4.4 attēls). Šī funkcija ir īpaši noderīga gadījumā, ja dati jau ir apkopoti pa klasēm, jo funkcija attēlo datus tādā veidā kā tie norādīti mainīgajā. barplot(niedres$platums)    Figure 4.4: Slokšņu/stabiņu grafika piemērs      4.2 Dati grafiku veidošanai Lai veidotu grafikus, esošos datus no gatavām datu tabulām nav jāsaglabā kā atsevišķus mainīgos -tos uzreiz var izmantot grafiku veidošanai. Ir vismaz trīs dažādi veidi kā norādīt attēlojamos mainīgos: (a) norādot pilnu datu objektu nosaukumu un tad kolonnas nosaukumu, kuru vēlas attēlot; (b) grafika veidošanas funkciju likt kā argumentu funkcijai with(). Visos šajos gadījumos izveidosies līdzīgs attēls (4.1 attēls), var atšķirties tikai paraksti zem asīm. plot(niedres$platums) with(niedres,plot(platums)) Ja ir nepieciešams uz x un y ass attēlot divu mainīgo datus, tad ir divi iespējamie risinājumi: (a) kā pirmo argumentu raksta uz x ass attēlojamo mainīgo, tad komats un uz y ass attēlojamais mainīgais; (b) kā pirmo raksta uz y ass attēlojamo mainīgo, tad tildes zīme ~ un uz x ass attēlojamais mainīgais. Abi varianti izveido identisku grafiku (4.5 attēls). plot(niedres$platums,niedres$garums)    Figure 4.5: Grafiks ar diviem mainīgajiem   plot(niedres$garums~niedres$platums)    Figure 4.6: Grafiks ar diviem mainīgajiem     4.3 Grafiku parametru noteikšana Programmā R grafikiem mainīt paramtrus var divos veidos – izmantojot speciālu funkciju par() vai arī rakstot argumentus iekavās pie citām grafiku veidošanas funkcijām. Funkciju par() lieto, lai noteiktu parametrus, kas ietekmē visus turpmākos grafikus, kāmēr konkrētais grafiskais ekrāns vai vide ir atvērta. Šī funkcija ir jāizsauc kā pirmā pirms grafika veidošanas funkcijas izsaukšanas. Daļu no parametriem var noteikt tikai kopā ar funkciju par().  4.3.1 Grafiku izvietojums lapā R piedāvā iespēju izvietot vienā lapā vairākus attēlus, kas tiek panākts izmantojot argumentus mfrow=, mfcol kopā ar funkciju par(), vai arī izmantojot unkciju layout(). Visi šie argumenti vai funkcija ir jānodefinē pirms grafiku funkcijām, kā arī jāņem vērā tas, ka šīs funkcijas zaudē spēku, ja tiek izmantota funkcija dev.off() vai arī grafiku logs tiek aizvērts. Argumenti mfrow= un mfcol= tiek izmantoti kopā ar funkciju par(), pēc sekojoša principa par(mfrow=c(rinduskaits,kolonnuskaits)). mfrow= un mfcol= atšķirība ir tā, ka pirmajā gadījumā grafiki tiek aizpildīta pēc rindu principa (pirmā rinda, tad otrā rinda), bet otrajā gadījumā aizpilda pēc kolonnu principa (pirmā kolonna, tad otrā kolonna). Funkcija layout() strādā pēc līdzīga principa (4.7 attēls), tikai šajā gadījumā ir iespējams nodefinēt kādā secībā grafiki izvietosies – secīgi vai jauktā veidā, kā arī ar šo funkciju iespējams nodefinēt arī izmērus katram no atsevišķajiem grafikiem. Zemāk minētajā piemērā visas trīs pirmās rindas dod vienādu rezultātu (reāli jāizmanto tikai viena). par(mfrow=c(2,2)) par(mfcol=c(2,2)) layout(matrix(c(1,2,3,4),ncol=2)) plot(niedres$garums) hist(niedres$garums) boxplot(niedres$garums) barplot(niedres$garums)    Figure 4.7: Vairāku grafiku izvietojums vienā lapā   Ja funkcijā layout() kāds no skaitļiem tiek atkārtots, tad grafiks tiks izvietot nevis vienā “rūtiņā”, bet gan divās, kāmēr pārējie grafiki izvietosies vienā rūtiņā (4.8 attēls). layout(matrix(c(1,1,2,3),ncol=2)) plot(niedres$garums) hist(niedres$garums) boxplot(niedres$garums)    Figure 4.8: Vairāku grafiku izvietojums vienā lapā     4.3.2 plot() grafiku tipi Pēc noklusējuma funkcija plot() veido izkliedes grafiku, bet to ir iespējams mainīt norādot papildus argumentu type= iekavās pie šīs funkcijas. Rezultātā var iegūt sešus dažādus grafiku veidus (4.9 attēls). par(mfrow=c(2,3)) plot(niedres$garums,type=&quot;l&quot;,main=&quot;type=\\&quot;l\\&quot;&quot;) plot(niedres$garums,type=&quot;h&quot;,main=&quot;type=\\&quot;h\\&quot;&quot;) plot(niedres$garums,type=&quot;b&quot;,main=&quot;type=\\&quot;b\\&quot;&quot;) plot(niedres$garums,type=&quot;o&quot;,main=&quot;type=\\&quot;o\\&quot;&quot;) plot(niedres$garums,type=&quot;s&quot;,main=&quot;type=\\&quot;s\\&quot;&quot;) plot(niedres$garums,type=&quot;p&quot;,main=&quot;type=\\&quot;p\\&quot;&quot;)    Figure 4.9: Funkcijas plot() grafiku veidi     4.3.3 Līniju parametri Līnijām, kas tiek attēlotas grafikos, ir iespējams nodefinēt vairākus parametrus. Tas tiek panākts ar atsevišķiem argumentiem, kurus lieto kopā ar funkcijām grafika izveidošanai. Pirmais no parametriem, kuru var mainīt, ir līnijas veids. To dara ar argumentu lty=, norādot skaitli no 0 līdz 6 (bez pēdiņām), vai arī lietojot līnijas veida anglisko nosaukumu (attiecīgi “blank”,“solid”, “dashed”, “dotted”, “dotdash”, “longdash”, “twodash”). Ir iespējams nodefinēt arī savu līnijas veidu - pēdiņās aiz lty= jāraksta skaitļi, kur attiecīgi pirmais skaitlis apzīmē līnijas garumu un otrais skaitlis atstarpes garumu (4.10 attēls). Šaja piemērā funkcija lines() tiek izmantota, lai grafikam pievienotu papildus līnijas. Funkcija ir lietojama tikai tad, ja pamatgrafiks jau ir izveidots. x&lt;-rep(10,10) plot(x,type=&quot;l&quot;,lty=1,ylim=c(3,11),axes=F,ann=F,lwd=2) lines(x-1,lty=2,lwd=2) lines(x-2,lty=3,lwd=2) lines(x-3,lty=4,lwd=2) lines(x-4,lty=5,lwd=2) lines(x-5,lty=6,lwd=2) lines(x-6,lty=&quot;664422&quot;,lwd=2) box()    Figure 4.10: Iespējamie līniju tipi grafikos   Lai noteiktu līniju platumu, lieto argumentu lwd=, norādot līnijas biezumu kā skaitli. Līnijas platums būs atkarīgs no tā, kur grafiks tiks attēlots, tas ir, ja grafiku apskatīsies uz ekrāna vai eksportēsiet kā failu, līniju platums var atšķirties. Ar argumentu lend= nosaka kāds būs līnijas nobeigums: apaļš (&quot;round&quot;) vai taisns (&quot;square&quot;&quot; vai &quot;butt&quot;). Arguments ljoin= nosaka kādā veidā līnijas savienojas savā starpā (ja ir lauzta līnija). Savienojums var būt punktveida (&quot;mitre&quot;), apaļš (&quot;round&quot;) un ass leņķis (&quot;bevel&quot;). Attēlā 4.11 var sekot tam, kā mainās līnijas izskats, mainot dažādus tās parametrus (platumu, veidu, savienojumu vietas). layout(matrix(c(1,3,5,2,4,5),ncol=2)) plot(niedres$garums,type=&quot;l&quot;) plot(niedres$garums,type=&quot;l&quot;,lty=4) plot(niedres$garums,type=&quot;l&quot;,lty=4,lwd=12) plot(niedres$garums,type=&quot;l&quot;,lty=4,lwd=12,lend=&quot;butt&quot;) plot(niedres$garums,type=&quot;l&quot;,lty=4,lwd=12,lend=&quot;butt&quot;,ljoin=&quot;bevel&quot;)    Figure 4.11: Līnijas izmaiņas, mainot dažādus parametrus     4.3.4 Simbolu veidi Tradicionālajiem grafikiem ir pieejami 26 iepriekš nodefinēti simbolu veidi datu attēlošanai, kurus var mainīt izmantojot argumentu pch= un norādot skaitli no 0 līdz 25 (4.12 attēls). Papildus ir iespējams norādīt arī burtus vai citus simbolus, tos liekot pēdīņās aiz argumenta pch=. par(mar=c(2,2,1,1)) layout(matrix(1:9,ncol=3)) x&lt;-rnorm(10) plot(x,ann=F) plot(x,pch=0,ann=F) plot(x,pch=5,ann=F) plot(x,pch=8,ann=F) plot(x,pch=12,ann=F) plot(x,pch=17,ann=F) plot(x,pch=23,ann=F) plot(x,pch=&quot;.&quot;,ann=F) plot(x,pch=&quot;A&quot;,ann=F)    Figure 4.12: Simbolu veidi     4.3.5 Virsraksti un teksti pie asīm Virsrakstus un tekstus pie asīm var noteikt gan ar argumentiem, gan ar atsevišķām funkcijām. Kā argumenti (piemēram, funkcijai plot()) nāk xlab= (izveido parakstu zem x ass), ylab= (izveido parakstu zem y ass) un main= (izveido virsrakstu), aiz vienādības zīmes pēdiņās rakstot atbilstošo tekstu (4.13 attēls). plot(niedres$garums,main=&quot;Parastā niedre&quot;,xlab=&quot;Kārtas skaitlis&quot;,ylab=&quot;Lapas garums (cm)&quot;)    Figure 4.13: Grafiks, kuram teksti definēti kā argumenti   Lai varētu ietekmēt vairāk parametrus, tekstus var norādīt arī ar atsevišķām funkcijām, bet šajā gadījumā, piemēram, pie plot() funkcijas jānorāda arguments ann=FALSE, lai programma pati neveidotu parakstus zem asīm. Virsrakstu definē ar funkciju title(), kur pēdiņās raksta nepieciešamo tekstu. Vispārīgā gadījumā tekstus pie asīm nosaka ar funkciju mtext(&quot;ko gribam redzēt&quot;, side=kurā.pusē, line=kurā.līnijā). Izvietojums (puse) atbilst asu izvietojumam (1 - x ass, 2 - y ass, 3 - augšējā ass, 4 - otrā y ass), teksta līnijas rēķina attiecībā pret asīm, tas ir, ja norādīs line=1, tad teksts būs pie pašas ass un, jo lielāks skaitlis, jo tālāk no ass atradīsies teksts (4.14 attēls). plot(niedres$garums,ann=FALSE) title(&quot;Parastā niedre&quot;) mtext(&quot;Kārtas skaitlis&quot;,side=1,line=1) mtext(&quot;Lapas garums (cm)&quot;,side=2,line=3)    Figure 4.14: Grafiks, kuram teksti definēti kā atsevišķas funkcijas     4.3.6 Teksts grafika iekšienē a nepieciešams izvietot tekstu grafika iekšienē, ir jāizmanto funkcija text(). Šai funkcijai kā argumentus jānorāda x un y koordinātes (atbilstoši asu skalām), kur jānovieto teksts un jānorāda pats teksts, kuru vēlas ievietot. Ir jāņem vērā, ka pēc noklusējuma teksts tiks izveitots tā, ka norādītās koordinātes ir teksts viduspunkts. Lai to mainītu, ir jānorāda papildus arguments pos= ar iespējamām vērtībām: 1 - teksts atrodas zem šī punkta; 2 - teksts atrodas pa kreisi no šī punkta; 3 - teksts atrodas virs šī punkta; 4 - teksts atrodas pa labi no šī punkta. Ja tekstam vajag mainīt orientāciju (lai tas nebūtu novietots horizontāli), jāizmanto papildus arguments srt=, kuram jānorāda teksta novietojums grādos. Piemērā grafikā (4.15 attēls) ir izvietoti divi uzraksti: &quot;pirmais&quot; - bez papildus argumentiem; &quot;otrais&quot; - novietots virs koordināšu punkta un 25 grādu slīpumā. plot(niedres$garums) text(20,20,&quot;pirmais&quot;) text(40,40,&quot;otrais&quot;,pos=3,srt=25)    Figure 4.15: Tekstu novietojuma piemērs     4.3.7 Tekstu parametri Tekstam var definēt dažādus parametrus, no kuriem svarīgākie būtu fonts, fontu grupa un burtu izmērs. Nosakot fontu, jānosaka kādai fontu grupai tas piederēs ar argumentu family=. Fontu grupas ir, piemēram, &quot;mono&quot;, &quot;serif&quot;, &quot;sans&quot;. Fontu tipu nosaka ar argumentu font= ar iespējamo vērību no 1 līdz 5, kur 1 apzīmē parastus burtus, 2 - bold, 3 - italic, 4 – bold italic un 5 - simboli. Argumentu family= var lietot tikai kopā ar funkciju par(), bet font= var izmantot kopā arī ar citām funkcijām. Lai definētu fonta tipu asīm, asu parakstiem un virsrakstiem, attiecīgi var lietot argumentus font.axis=, font.lab= un font.main=. Burtu izmēru var noteikt ar diviem argmentiem ps= un cex=. Arguments ps= nosaka absolūto burtu izmēru punktos. cex= nosaka relatīvo burtu izmēru, piemēram, cex=1.5 nozīmēs, ka burtiem ir jābūt 1.5 reizes lielākiem nekā ir standarta izmēra burti. ps= lieto tikai kopā ar par(), bet cex= var izmantot kopā arī ar citām funkcijām. cex.axis=, cex.lab= un cex.main= attiecīgi izmanto, lai apzīmētu asu simbolu, asu parakstu un virsrakstu relatīvo izmēru. Piemērā (4.16 attēls) ir izmainīti izmēri virsrakstiem, parakstiem un skaitļiem pie asīm, kā arī katram no šiem parametriem ir izmantots cits fonta tips. plot(niedres$garums,main=&quot;Parasta niedre&quot;,xlab=&quot;Kartas skaitlis&quot;,      ylab=&quot;Lapas garums (cm)&quot;,cex.main=3,cex.lab=1.5,cex.axis=0.8,      font.main=3,font.axis=4,font.lab=2)    Figure 4.16: Teksta parametru izmaiņas     4.3.8 Asis Ja ir nepieciešams noteikt asu garumu (to ierobežojot kādā intervālā, vai arī tieši otrādi - padarot asi garāku, nekā tā tiek automātiski veidota) (4.17 attēls), var izmantot argumentus xlim= un ylim=, ko lieto, piemēram, ar funkciju plot(). Abiem argumentiem pieraksts ir vienāds xlim=c(sākuma.vērtība,beigu.vērtība). par(mfcol=c(1,2)) plot(niedres$garums) plot(niedres$garums,xlim=c(10,40),ylim=c(-10,80))    Figure 4.17: Asu garuma izmaiņu piemērs   Ja grib ietekmēt vairākus ass parametrus, tad jāizmanto funkcija axis(), bet pirms tam, piemēram, kā arguments pie plot(), jāraksta axes=FALSE, lai programma automātiski pati neveidotu asis. Funkcijas pieraksts ir axis(kura.ass, at=seq(sākuma.vērtība,beigu.vērtība,intervāls), labels=c(ko.attēlot)). Asu numerācija ir sekojošā: apakšējā ir 1, kreisā ir 2, augšējā 3 un labā ir 4. Ja argumentu labels= nenorāda, tad tiek attēloti tie paši skaitļi, kas ir pie argumenta at=. Ar argumentu las= var mainīt skaitļu/tekstu novietojumu pie ass, kur 0 nozīmē parallēls asij, 1 - horizontāls, 2 - perpendikulārs asij, 3 - vertikāls. Piemērā (4.18 attēls) x asij nodefinēts, ka skaitļiem pie ass jābūt no 0 ik pēc 15, toties y asij pie skaitļiem 20, 40 un 60 ir jāparādas tekstam, nevis skaitļiem. par(mfcol=c(1,2)) plot(niedres$garums) plot(niedres$garums,axes=FALSE) axis(1,at=seq(0,50,15),las=2) axis(2,at=c(20,40,60),labels=c(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;),las=1) box()    Figure 4.18: Asu definēšanas piemērs     4.3.9 Divas y asis Lai arī daļa speciālistu atzīst, ka grafiki ar y asīm nav labi, reizēm tādus ir nepieciešamas izveidot. Pirmkārt, ar funkciju par() un argumentu mar= jāizmaina malu izmēri, lai otrai y asij būtu vietas. Pēc tam jāuzzīmē pamatgrafiks, aiz kura nāk funkcija par(new=TRUE), kas ļauj pa “virsu” zīmēt otru grafiku. Otrajam grafikam jālieto argumenti axes=FALSE un ann=FALSE, lai apzīmējumi nepārklātos. Tālāk jau ar funkcijām axis() un mtext() iegūst vēlamos apzīmējumus pie atbilstošās ass (4.19 attēls). par(mar=c(5,5,2,5)) plot(niedres$garums,type=&quot;l&quot;) par(new=TRUE) plot(niedres$platums,type=&quot;l&quot;,lty=3,axes=F,ann=F) axis(4,at=seq(0,8,2)) mtext(side=4,line=2,&quot;platums&quot;)    Figure 4.19: Grafiks ar divām y asīm     4.3.10 Krāsas Ir iespējams mainīt krāsas visām grafika sastāvdaļām, izmantojot dažādus argumentus (4.20 attēls). Šos argumentus var rakstīt kā daļu no funkcijas par() un šajā gadījumā krāsas būs noteiktas visiem grafikiem, vai arī lietot kā daļu, piemēram, no funkcijas plot() un šajā gadījumā krāsas mainīsies tikai konkrētajam grafikam. Vieglākais veids kā apzīmēt krāsu, ir lietot tās anglisko nosaukumu, piemēram, &quot;red&quot; vai &quot;darkgreen&quot;. Lai redzētu visu pieejamo krāsu nosaukumus, jāraksta komanda colors(). Pamatā ir trīs argumenti krāsu maiņai: col=, bg= un fg=. col=&quot;krāsas.nosaukums&quot; ir visbiežāk lietotais krāsas parametrs, ar kuru pārsvarā tiek noteikta datu simbolu, līniju, tekstu un citu sastāvdaļu, kas atrodas grafikā krāsa. Lai noteiktu asu, asu parakstu, virsrakstu un apakšvirsrakstu krāsas, jālieto attiecīgi argumenti col.axis=, col.lab=, col.main= un col.sub=. fg=&quot;krāsas.nosaukums&quot; izmanto, lai mainītu asu un grafika malu krāsu, un daļēji tas sakrīt ar col.axis= un col.main= argumentiem. bg=&quot;krāsas.nosaukums&quot; nosaka fona krāsu, šo argumentu var lietot kopā tikai ar funkciju par(). par(bg=&quot;lightblue&quot;) plot(niedres$garums,fg=&quot;red&quot;,main=&quot;Slikts grafiks&quot;,col.main=&quot;green&quot;,col.axis=&quot;yellow&quot;)    Figure 4.20: Krāsu izmantošanas piemērs     4.3.11 Leģenda Tradicionālajiem grafikiem leģendas programmā R veido ar atsevišķu funkciju legend(). Leģenda parasti ir novietota grafika iekšējā daļā (4.21 attēls). Dotajai funkcijai kā argumentus jānorāda: (a) leģendas novietojums - to nosaka ar x un y koordināti leģendas rāmīša augšējam kreisajam stūrim (koordinātes nosaka atbilstoši asu vērtībām, piemēram, ja uz x ass vērtības ir robežās no 5 līdz 10, bet uz y ass no 100 līdz 200, tad leģenas koordināte varētu būt 6 un 125); (b) nosaukumi, kuriem jāparādās leģendā; (c) datu simbolu/līniju veidu apzīmējumi (tiem ir jāsakrīt ar apzīmējumiem, kas izmantoti, lai definētu grafiku). par(mar=c(5,5,2,5)) plot(niedres$garums,type=&quot;l&quot;) par(new=TRUE) plot(niedres$platums,type=&quot;l&quot;,lty=3,axes=F,ann=F) axis(4,at=seq(0,8,2)) mtext(side=4,line=2,&quot;platums&quot;) legend(0,7,lty=c(1,3),c(&quot;garums&quot;,&quot;platums&quot;))    Figure 4.21: Grafiks ar leģendu     4.3.12 Līnijas grafikos Ja grafikā ir nepieciešams izvietot taisnu līniju, var izmantot funkciju abline(). Ja ir nepieciešams uzzīmēt slīpu līniju, tad ir jānorāda divi skaitļi, kas attiecīgi norāda puktu, kurā līnija krusto x asi un līnijas slīpumu (intercept), vai arī jāizmanto papildus funkcija lm(), kas izveidos regresijas līkni grafikā attēlotajiem mainīgajiem (4.22 attēls). Ja nepieciešams izveidot horizontālas līnijas, tad jānorāda arguments h= un vērtības (viena vai vairākas), kurās vietās horizontālās līnijas krustos y asi. Attiecīgi vertikālām līnijām ir jānorāda arguments v=. plot(niedres$garums~niedres$platums) abline(lm(niedres$garums~niedres$platums)) abline(h=c(30,40),lty=c(2,3)) abline(v=c(3,5),col=&quot;grey55&quot;)    Figure 4.22: Grafiks ar papildus līnijām      4.4 Grafiku saglabāšana Programmā R iegūtos grafikus ir iespējams saglabāt dažādos formātos, izmantošanai citās programmās. Jau izveidotu grafiku, kas redzams uz ekrāna, ir iespējams saglabāt izmantojot opciju File/Save as... un izvēloties nepieciešamo faila veidu (Metafile, Postcript, PDF, Png, Bmp, Jpeg (kvalitāte 50%, 75% vai 100%), kā arī grafiku ir iespējams ielikt atmiņa File/Copy to clipboard... Saglabājot jau izveidotu grafiku, ir jāņem vērā, ka uz ekrāna grafiks ne vienmēr tiek attēlots pareizākajās proporcijās, sevišķi, ja ekrāna izmērus esat pielāgojuši paši. Grafikus ir iespējams uzreiz saglabāt nepieciešamajā formātā ar atbilstošu komandu rindu, tikai šajā gadījumā grafiks netiks parādīts uz ekrāna. Lai grafikus uzreiz saglabātu, pirms visām komandu rindām, ar kurām nosaka grafika parametrus, ir jāraksta atbilstoša komanda, kas nosaka saglabājamā faila formātu un faila nosaukumu: postscript(file=&quot;nosaukums.ps&quot;) png(file=&quot;nosaukums.png&quot;) pdf(file=&quot;nosaukums.pdf&quot;) jpeg(file=&quot;nosaukums.jpg&quot;) bmp(file=&quot;nosaukums.bmp&quot;) Pēc tam, kad ir uzrakstītas visas vajadzīgās grafika komandu rindas, ir “jāatslēdz” komanda, ar kuru noteica faila formātu un faila nosaukumu. Pretējā gadījumā visi nākamie grafiki arī tiks saglabāti konkrētajā failā, aizstājot iepriekšējo. Lai to izdarītu, raksta komandu dev.off().   "],
["datu-izzinasana-un-normalitates-testi.html", "5. nodaļa. Datu izzināšana un normalitātes testi 5.1 Datu izzināšana 5.2 Normalitātes testi", " 5. nodaļa. Datu izzināšana un normalitātes testi  5.1 Datu izzināšana Pirms uzsākt reālu datu analīzi, veicot dažādus statistiskos testus, vienmēr vajag sākotnējo datu izzināšanu, izmantojot dažādus datu grafiskos attēlojumus. Tādējādi ir iespēja jau pirms statistisko analīžu veikšanas novērtēt vai datos redzamas kādas tendences, savstarpējās saistības, grupēšanās, kā arī secināt vai datos nav kādas dīvainas, neiederīgas vērtības. Kā piemērs izmantots datu fails niedres2.txt, kas satur informāciju par niedru lapu garumu un platumu trīs parauglaukumos. niedr&lt;-read.table(file=&quot;niedres2.txt&quot;,header=T,sep=&quot;\\t&quot;,dec=&quot;.&quot;) str(niedr) ## &#39;data.frame&#39;:    50 obs. of  3 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ... ##  $ paraug : Factor w/ 3 levels &quot;Austr&quot;,&quot;Riet&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Vienkāršākais grafiks datu apskatīšanai ir izkliedes grafiks, ko programmā R var iegūt ar funkciju plot(). Šajā grafikā (5.1 attēls) uz x ass atlikts novērojuma kārtas numurs, uz y ass novērojumu vērtības. Pēc izkliedes grafika var gūt priekštatu par vērtību izkliedi, gan arī novērtēt vai nav kādas ekstremāli mazas vai lielas vērtības. plot(niedr$garums)    Figure 5.1: Viena mainīgā izkliedes grafiks   Ja funkcijā plot() norāda divus mainīgos, tad vienlaicīgi var novērtēt gan šo mainīgo vērtību saistību (5.2 attēls), gan arī pamanīt kādus ekstrēmus, ko nav iespējams novērtēt skatot katru mainīgo atsevišķi. plot(niedr$garums,niedr$platums)    Figure 5.2: Divu mainīgo izkliedes grafiks   Box-plot grafiki, ko iegūst ar funkciju boxplot(), ir piemēroti, lai novērtētu vērtību izkliedi datos (5.3 attēls). Box-plot grafikā līnija, kas atrodas taisntūra vidū, atbilst mediānai, taisnstūra apakšējā un augšējā mala attiecīgi ir 1. un 3. kvartile. Apakšējā un augšējā līnija attiecīgi ir minimālā un maksimālā vērtība datos, ar piebildi, ka šīs līnijas neatrodas tālāk kā 1,5 reiz taisntūra platums (attālums starp 1. un 3. kvartili). Ja minimālā vai maksimālā vērtība ir tālāk nekā šīs 1,5 reizes, tad šos novērojumus apzīmē ar punktu. boxplot(niedr$garums)    Figure 5.3: Box-plot grafiks vienam mainīgajam   Ja funkcijā {boxplot() norāda mainīgo, kas satur dalījumu līmeņos, tad atsevišķš grafiks tiek izveidots katram no dalījuma līmeņiem (5.4 attēls). Pēc šī grafika var salīdzināt datu izkliedi uzreiz vairākiem līmeņiem. boxplot(niedr$garums~niedr$paraug)    Figure 5.4: Box-plot grafiks trīs paraugkopām   Gadījumos, kad novērojumu skaits ir salīdzinoši mazs, tad labāk datu izkliedi raksturo punktu grafiks (5.5 attēls), ko var iegūt ar funkciju stripchart(). Šajā grafikā katrs novērojums ir attēlots ar kvadrātiņi un visi novērojumi izkārtoti vienā strīpā. stripchart(niedr$garums)    Figure 5.5: Punktu grafiks   Ja novērojumi pārklājas un nav iespējams precīzi attēlā novērtēt, cik daudz novērojumu atbilst katrai vērtībai, funkciju stripchart() var papildināt ar argumentu method=&quot;stack&quot;, kas novietot kvadrātiņus blakus, ja tie pilnībā pārklājas (5.6 attēls). Arguments vert=T nodrošina, ka grafiks novietojas vertikāli, nevis horizontāli. stripchart(niedr$garums,method=&quot;stack&quot;,vert=T)    Figure 5.6: Modificēts punktu grafiks   Vēl viens plaši izmantots datu attēlošanas veids ir histogramma, ko programmā R var izveidot ar funkciju hist(). Histogrammā dati tiek sadalīti klasēs un tādējādi var novērtēt vērtību sadalījuma veidu - vienmērīgi, zvanveidīgi, ar izteiktām minimālām vai maksimālām vērtībām (5.7 attēls). Funkcijai var mainīt argumentus gan nosakat cik klasēs dalīt datus, gan arī nosakot tieši dalījuma robežas. hist(niedr$garums)    Figure 5.7: Pazīmes niedru lapu garums histogramma     5.2 Normalitātes testi  5.2.1 Grafiskā analīze Daudzu statistisko metožu pieņēmums ir, ka analizējamie dati nāk no ģenerālkopas, kura atbilst normālajam sadalījumam. Lai par to pārliecinātos, ir jāveic noteikti statistiskie testi. Jaunākajā statistiskajā literatūrā arvien biežāk kā pamatmetode normalitātes novērtēšanai tiek izmantota grafiskā analīzē, nevis analītiskie testi. Viens no grafiku veidiem, ko izmantot normalitātes novērtēšanai, var būt histogramma (5.7 attēls). Histrogrammai ir jāveido apmēram zvanveidīgs izskats, lai pieņemtu, ka dati atbilst normālajam sadalījumam. Ar šo grafiku veidu problēma ir tā, ka histogrammas izskats lielā mērā būs atkarīgs no tā, cik klasēs dati ir sadalīti. Uzticamāks grafika veids ir tā saukti QQ grafiki, kas attēlo attiecību starp reālo datu kvantilēm un teorētisko datu kvantilēm (teorētiskie dati veidoti balstoties uz reālo datu statistiskajiem rādītājiem tā, lai tie atbilstu normālajam sadalījumam). Ja reālie dati atbilst normālajam sadalījumam, tad grafikā visi punkti novietojas uz diagonāles. Programmā R QQ grafiku veido ar funkciju qqnorm(), kurai kā argumentu norāda reālos datus. Papildus var izmantot arī funkciju qqline(), kas novelk līniju, lai būtu vieglāk interpretēt rezultātus. Iegūtajā grafikā (5.8 attēls) ideālā gadījumā visiem punktiem būtu jāatrodas uz taisnes, bet nelielas novirzes arī ir akceptējamas. Lai iemācītos strādāt ar šādiem grafikiem, var ģēnerēt mākslīgus datus no normālā sadalījuma un skatīties kā kātreiz izskatās QQ grafiks. qqnorm(niedr$garums) qqline(niedr$garums)    Figure 5.8: QQ grafiks niedru lapu garumam   Paketē car ir funkcija qqPlot(), kas arī veido QQ grafiku, tikai tas ir papildināts ar līnijām, kas parāda 95% ticamības intervālu (5.9 attēls), tādējādi atvieglojot interpretāciju. Ja visi punkti atrodas starp raustītajām līnijām, tad ar 95% pārliecību var apgalvot, ka dati nāk no ģenerālkopas, kas atbilst normālajm sadalījumam. library(car) qqPlot(niedr$garums)    Figure 5.9: Modificēts QQ grafiks niedru lapu garuma     5.2.2 Analītiskā analīze Ja ir nepieciešams daudz formālāks veids kā novērtēt datu atbilstību normālajam sadalījumam, var izmantot kādu no analītiskajām metodēm. R bāzes versijā ir pieejams Šapiro-Vilka normalitātes tests, ko var iegūt ar funkciju shapiro.test(). Funkcijai kā arguments jānorāda tikai mainīgais, kuram veikt normalitātes testu. Nulles hipotēze par to, ka dati atbilst normālajam sadalījumam nebūs noraidīta, ja iegūtā p-vērtība būs lielāka par izvēlēto būtiskuma līmeni. shapiro.test(niedr$garums) ##  ##  Shapiro-Wilk normality test ##  ## data:  niedr$garums ## W = 0.99101, p-value = 0.9668 Secinājums: pie būtiskuma līmeņa \\(\\alpha=0,05\\) pazīmes niedru lapu garums vērtības atbilst normālajam sadalījumam, jo p-vērtība ir lielāka par noteikto būtiskuma līmeni (0,97&gt;0,05). Funkciju shapiro.test() var izmantot arī kopā ar funkciju tapply(), tādējādi veicot šo testu vairākiem dalījuma līmeņiem uzreiz. tapply(niedr$garums,niedr$paraug,shapiro.test) ## $Austr ##  ##  Shapiro-Wilk normality test ##  ## data:  X[[i]] ## W = 0.8863, p-value = 0.04028 ##  ##  ## $Riet ##  ##  Shapiro-Wilk normality test ##  ## data:  X[[i]] ## W = 0.94264, p-value = 0.3508 ##  ##  ## $Ziem ##  ##  Shapiro-Wilk normality test ##  ## data:  X[[i]] ## W = 0.90337, p-value = 0.09103 Secinājums: pie būtiskuma līmeņa \\(\\alpha=0,05\\) pazīmes niedru lapu garums vērtības atbilst normālajam sadalījumam Rietumu un Ziemeļu parauglaukumos, jo p-vērtības ir lielākas par noteikto būtiskuma līmeni (0,35&gt;0,05 un 0,09&gt;0,05), toties Austrumu parauglaukuma dati neatbilst normālajam sadalījumam, jo p-vertība ir mazāka par noteikto būtiskuma līmeni (0,04&lt;0,05). Programmā R ir pieejama pakete nortest, kurā ir apvienoti pieci dažādi normalitātes testi, piemēram, Andersona-Darlinga tests un Lilliefora (Kolmogorova-Smirnova) tests. Testi savā starpā atšķiras ar algoritmiem kādā veidā salīdzina reālos datus ar teorētiski sagaidāmajiem, attiecīgi arī iegūtās p-vērtības starp testiem mēdz atšķirties. Daļa no testiem ir striktāki, daļa mazāk strikti. library(nortest) ad.test(niedr$garums) ##  ##  Anderson-Darling normality test ##  ## data:  niedr$garums ## A = 0.17373, p-value = 0.9223    "],
["literatura.html", "6. nodaļa. Literatūra", " 6. nodaļa. Literatūra    Arhipova, I., and S. Bāliņa. 2006. Statistika Ekonomikā. Risinājumi Ar SPSS Un Microsoft Excel. Datorzinību Centrs.   Crawley, M.J. 2007. The R Book. Wiley.   Everitt, B., and T. Hothorn. 2006. A Handbook of Statistical Analyses Using R. CRC Press.   Johnson, D.H. 1999. “The Insignificance of Statistical Significance Testing.” Journal of Wildlife Management 63 (3): 763–72.   Liepa, Imants. 1974. Biometrija. Zvaigzne.   Maindonald, J., and W.J. Braun. 2010. Data Analysis and Graphics Using R. An Example-Based Approach. Cambridge.   Murrell, P. 2006. R Graphics. CRC Press.   R Core Team. 2012. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. http://www.R-project.org/.   Sarkar, D. 2008. Lattice. Multivariate Data Visualization with R. Springer.   Sokal, R.R., and F.J. Rohlf. 1995. Biometry. W.H. Freeman; company.   Stephens, P.A., S.W. Buskirk, G.D. Hayward, and C.M. Del Rio. 2005. “Information Theory and Hypothesis Testing: A Call for Pluralism.” Journal of Applied Ecology 42: 4–12.   Verzani, J. 2005. Using R for Introductory Statistics. Chapman; Hall/CRC.   Wicham, H. 2009. Ggplot2. Elegant Graphics for Data Analysis. Springer.   Zuur, A.F., E.N. Ieno, and G.M. Smith. 2007. Analysing Ecological Data. Springer.   "]
]
