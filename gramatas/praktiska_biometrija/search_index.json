[
["index.html", "Praktiskā biometrija 1. nodaļa. Ievads", " Praktiskā biometrija Didzis Elferts 2016-04-05   1. nodaļa. Ievads Šī grāmata ir mans mēģinājums samērā vieglā formā ar minimālu teorijas materiālu sniegt praktiskus padomus statistisko analīžu veikšanā biologiem. Tā kā uzsvars ir likts uz vārdu ‘’praktiski’’, tad lielāko grāmatas daļu sastāda piemēri tam, kā veikt katru no apskatītajiem statistiskajiem testiem. Plašāka teorētiskā pamatojuma iegūšanai noderēs citu autoru darbi. Nenoliedzami nopietnākais darbs latviešu valodā biometrijas jomā ir jāmin Liepa (1974) grāmata, angļu valodā tas būtu kāds no Sokala un Rohlfa izdevumiem, piemēram, Sokal and Rohlf (1995). Vieglākā formā nelielu teorētisko pamatojumu statistiskas pamatmetodēm latviešu valodā var meklēt Arhipova and Bāliņa (2006), tikai tajā piemēri būs no ekonomikas jomas. Par modernākām metodēm informāciju var meklēt, piemēram, Zuur, Ieno, and Smith (2007). Programma R ir izvēlēta kā rīks, ar kuru veikt prakstisko datu analīzi. Kāpēc tieši programma R? Pirmais arguments ir tas, ka šī programma ir bezmaksas, attiecīgi ir pieejama jebkuram lietotājam, kas izvēlēties izmantot šo grāmatu. Otrkārt, pamatdarbības programmā R notiek ar komandu rindām, kas lietotājam liek aizdomātas par darbībām, kuras viņš taisās veikt, nevis vienkārši kaut ko ņemts un klikšķināt. Trešais iemesls būtu tas, ka R šobrīd ir straujāk attīstošās statistikas programma, kas ļauj tajā veikt arī pašas jaunākās analīzes. Dotais materiāls ir mans pirmais mēģinājums uzrakstīt grāmatu par R, tāpēc tajā var ļoti daudz vēl pilnveidojamu lietu. Kā alternatīvus materiālus statistisko analīžu veikšanai programmā R var izmantot, piemēram, Verzani (2005), Everitt and Hothorn (2006) vai Maindonald and Braun (2010).  "],
["biometrija-un-datu-analize.html", "2. nodaļa. Biometrija un datu analīze 2.1 Kas ir biometrija? 2.2 Paraugkopa un ģenerālkopa 2.3 Hipotēžu pārbaude", " 2. nodaļa. Biometrija un datu analīze  2.1 Kas ir biometrija? Biometrijas jēdzienam ir vairāki skaidrojumi, bet šīs grāmatas ietvaros ar to sapratīs statistisko un matemātisko metožu pielietošanu bioloģisko datu analīzei. Vienkāršoti varētu teikt, ka biometrija ir statistika biologiem. Kā statistikas virzienu arī biometrijai var izškirt divus virzienus: aprakstošā statistika un secinošā statistika. Aprakstošā statistika iekļauj metodes, kas paredzētas informācijas par paraugkopu vai ģenerālkopu organizēšanai, grafiskai attēlošanai un apkopošanai. Secinošā statistika iekļauj metodes, kas izmanto paraugkopas informāciju, lai izdarītu secinājumus par visu ģenerālkopu.   2.2 Paraugkopa un ģenerālkopa Jebkurā eksperimentā vai pētījumā tiek izraudzīti objekti, kurus pētīt, piemēram, putnus, augus, konkrētas šūnas vai tikai to sastāvdaļas, vai arī kompleksi kā biotops. Katram no šiem objektiem pēta konkrētas pazīmes, piemēram, lidspalvu garums, hlorofila koncentrācija vai sugu skaits konkrētā biotopā. Pētījumam vienmēr iegūst nevis vienu konkrētu pazīmes vērtību (objektu), bet gan vairākas, lai būtu iespējams novērtēt variāciju šajās vērtības. Šīs daudzās vērtības var veidot ģenerālkopu vai paraugkopu. Ģenerālkopa jeb populācija sastāv no visām konkrētās pazīmes vērtībām, un tās lielums ir atkarīgs no pētījuma jautājuma. Piemēram, ja pētījuma mērķis ir noskaidrot kāds ir vidējais priežu garums Latvijā, tad ģenerālkopa būs visas priedes Latvijā. Ja jautājumu sašaurina līdz vidējam priežu garumam Dundagas novadā, tad arī ģenerālkopa būs šaurāka. Vairumā pētījumu nav iespējams aptvert visas iespējamās ģenerālkopas vērtības, tāpēc tiek izraudzīta tikai daļa no tās. Šo daļu no ģenerālkopas, kuru pēta, sauc par paraugkopu.   2.3 Hipotēžu pārbaude Veicot pētījumus, viens no uzdevumiem ir izdarīt secinājumus par to vai vērojamas atšķirības, saistības vai ietekme, piemēram, vai pastāv atšķirība starp augu vidējo garumu dažādos mēslošanas apstākļos, vai temperatūru pieaugums maina dzīvnieku uzvedību, utt. Viena no pieejām secinājumu izdarīšanai ir tā saucamā hipotēžu pārbaude. Pirms pētījuma veikšanas izvirza tā saucamo Nulles hipotēzi (\\(H_0\\)), kas tālāk tiek pārbaudīta jau pētījuma laikā. Nulles hipotēze parasti apgalvo, ka starp diviem lielumiem nav atšķirības vai, ka nav vērojama ietekme. Apzīmējums \\(H_0:X=Y\\) nozīmē, ka Nulles hipotēze apgalvo, ka rādītāji X un Y savā starpā neatšķiras jeb tie ir vienādi. Vienlaicīgi ar Nulles hipotēzi izvirza arī alternatīvo hipotēzi, kas tiek pieņemta, ja Nulles hipotēze nav spēkā. Gadījumā ar X un Y alternatīvā hipotēze būs \\(H_1:X\\neq Y\\). Ir skaidrs, ka ļoti reti X un Y tiešām būs identiski un gandrīz vienmēr būs kaut kāda atšķirība. Tāpēc statistiskajos testos, kurus balsta uz hipotēžu pārbaudi, ir pieņemts aprēķināt p-vērtības, kuru interpretācija ir dažāda. Viena no interpretācijām ir, ka p-vērtība norāda kāda ir iespējamība iegūt tik pat ekstrēmus datus (vai atšķirību rādītājos) kā novērotie, ja pieņem, ka Nulles hipotēze ir patiesa. Bioloģijā visbiežāk Nulles hipotēzi noraida un akceptē alternatīvo hipotēzi, ja p-vērtība ir mazāka par 0,05. Šo līmeni sauc par būtiskuma līmeni un apzīmē ar \\(\\alpha\\). Vēl pieņemtie būtiskuma līmeņi ir 0,01 un 0,001. Attiecīgi no būtiskuma līmeņa atvasina citu rādītāju, kas ir ticamības līmenis (P) un to aprēķina kā \\(P=1-\\alpha\\). Parādot rezultātus publikācijās vai kādos citos darbus vēlams būtu norādīt tieši kādair bijusi p-vērtība, nevis vienkārši rakstīt, piemēram, p&lt;0,05. Noraidot Nulles hipotēzi, mēs varam apgalvot, ka pastāv, piemēram, statistiski būtiska atšķirība starp lielumiem X un Y, bet tas automātiski nenozīmē, ka šī atšķirība ir arī bioloģiski būtiska, piemēram, pie liela paraugkopas apjoma izmaiņas garumā par 1% arī var būt statistiski būtiskas, bet vai varam apgalvot ka tās ir bioloģiski būtiskas. Nulles hipotēzes nenoraidīšana vēl nenozīmē, ka tā ir patiesa, jo, iespējams, paraugkopas apjoms bija pārāk mazs, sevišķi, ja p-vērtības ir tuvu būtiskuma līmeņa vērtībām. Vēl attiecībā uz hipotēžu noraidīšanu un akceptēšanu ir jāpiemin 1. un 2. tipa kļūdas. 1. tipa kļūda rodas tad, ja Nulles hipotēze tiek noraidīta, kaut arī tā ir patiesa. Šāda iespējamība ir vienāda ar izvēlēto būtiskuma līmeni. 2. tipa kļūda rodas tad, ja Nulles hipotēze tiek akceptēta, ka arī tā nav patiesa. Veicot eksperimentus un pētījumus ir jāņem vērā šādas iespējamības un jācenšās tās kaut daļēji kontrolēt. Jāpiemin gan, ka hipotēžu pārbaudes teorija un balstīšanās uz p-vērtībām pēdējo desmit līdz divdesmit gadu laikā ir ievērojami apšaubīta un ir ieteikumi izmantot citas pieejas, piemēram, secinājumus balstīt uz ticamības intervāliem, vai arī izmantot modeļu izvēles kritērijus, Beijesa (Bayesian) metodes. Ieskatu problēmās un alternatīvās ar hipotēžu pārbaudi var gūt Johnson (1999) un Stephens et al. (2005) rakstos. Šajā grāmatā izmantoti gan klasiskā hipotēžu pārbaudes metode, gan arī citas alternatīvas.   "],
["ievads-darba-ar-programmu-r.html", "3. nodaļa. Ievads darbā ar programmu R 3.1 Kas ir programma R un kā uzsākt darbu? 3.2 Darbs ar R", " 3. nodaļa. Ievads darbā ar programmu R  3.1 Kas ir programma R un kā uzsākt darbu?  3.1.1 R vide R ir vienlaicīgi datorprogramma un valoda (veidojusies no programmēšanas valodas ‘S’), kas paredzēta datu apstrādei, aprēķiniem un grafiku veidošanai. Visi piemēri šajā grāmatā ir veidoti programmas R versijā 3.2.2. (R Core Team 2012). R priekšrocības ir:  tā ir atvērtā koda programma, kas nepārtraukti tiek papildināta un uzlabota, un šajā darbā ir iesaistīti tūkstošiem cilvēku visā pasaulē} R ir izmantojams uz dažādām datoru platformām: Unix, Linux, Windows, MacOS; lietotājam ir dota iespēja kontrolēt visus parametrus veicot dažādus aprēķinus; R ir ļoti labas grafiskās iespējas, kas ļauj veidot augstas kvalitātes grafikus.    3.1.2 R instalācija un papildus paketes Lai instalētu programmu R, ir nepieciešams lejupielādēt Jūsu izmantotajai platformai atbilstošo R instalācijas failu no CRAN servera. Serveru adreses, kā arī citu informāciju var atrast mājas lapā http://www.R-project.org Pirmkārt, ir jāuzinstalē pamatfails R-base. Programma R ir veidota tā, ka R-base satur tikai daļu no nepieciešamajām funkcijām, pārējās ir pieejamas papildus paketēs. Tās var uzinstalēt trīs veidos:  izmantojot funkciju install.packages() un norādot instalējamās paketes nosaukumu. programmā R komandu rindā izvēlas Packages/Install package(s)... Tad izvēlas tuvāko serveri un paketes, kuras nepieciešams instalēt. ja paketes pirms tam tika lejupielādētas datorā, tad izvēlas opciju Packages/Install package(s) from local zip files...  Ja kāda no paketēm ir nepieciešama konkrētajā darba sesijā, tad pirms lietošanas tā ir „jāpievieno” ar funkciju library(), kur iekavās norādīts nepieciešamās paketes nosaukums, piemēram: library(grid)   3.1.3 Palīdzības iegūšana Papildus informāciju un palīdzību darbam ar R var iegūt no dažādām pamācībām, kas brīvi pieejamas internetā. Par programmu R ir arī ļoti daudz grāmatu, no kurām nopietnākais darbs ir Crawley (2007). Ir pieejama arī R iekšējā palīdzībā. Ja nepieciešams iegūt palīdzību par kādu konkrētu funkciju, vieglākais veids ir izmantot help() funkciju, kurai iekavās norādīts otras funkcijas nosaukums, piemēram: help(plot) Otrs variants ir rakstīt ? zīmi pirms funkcijas nosaukuma. Jāņem vērā, ka šādā veidā ir iespējams meklēt palīdzību tikai par tām funkcijām, kuras atrodas konkrētajai darba sesijai pievienotajās paketēs. Ja nepieciešams meklēt funkciju visās instalētajās paketēs, tad jāizmanto divas ? zīmes. ??plot    3.2 Darbs ar R  3.2.1 Komandu veidošana R vidē visas komandas tiek rakstītas pēc &gt; zīmes (tā nav pašam jāraksta). Ja komandu rinda ir pārāk gara, tad pēc jebkura argumeta, vai arī pēc iekavām, komata, utt var spiest Enter taustiņu un turpināt pierakstu jaunā rindā. Šajā gadījumā automātiski parādīsies + zīme. Ja komanda tiek uzrakstīta pilnībā un nospiests Enter, šī komanda tiek izpildīta. Ja komanda neizpildās, bet parādās + zīme, tas nozīmē, ka komandas pierakstā ir kļūda un trūkst, piemēram, kādas iekavas. Komandu rindas galā var pievienot arī komentāru, pirms komentāra ir jāraksta # zīme. R vidē atstarpes starp dažādiem objektiem, iekavām tiek ignorētas, izņēmums ir kombinācija &lt;-, ar kuru objektiem piešķir noteiktu vērtību. Rakstot komandas ir būtiski ievērot lielo un mazo burtu izvietojumu, jo šajā gadījumā apzīmējums AA nebūs tas pats, kas aa.   3.2.2 Kalkulators Programmu R savā veidā var izmantot kā kalkulatoru, ar kura palīdzību ir iespējams veikt dažādus aprēķinus. 4+7 ## [1] 11 log(8,2) ## [1] 3 exp(2) ## [1] 7.389056   3.2.3 Datu veidi R vidē pārsvarā lieto trīs veidu datus: skaitliskos (numeric), rakstu zīmes (character) un loģiskos (logical). Skaitliskie dati ir skaitļi, un tikai šāda veida objektus var izmantot, lai veiktu aprēķinus. Rakstu zīmju datus parasti izmanto, lai norādītu mainīgajiem nosaukumus, kā arī, lai veiktu datu grupēšanu. Loģiskajiem datiem var būt divas vērtības TRUE vai FALSE (jeb T un F).   3.2.4 Datu struktūras Četras galvenās datu struktūras R vidē: vektors (vector), matrice (matrix), saraksts (list) un datu tabula (data frame).  3.2.4.1 Vektors Vektors ir viendimensionāla datu struktūra, kas var sastāvēt tikai no viena tipa datiem –- skaitļiem vai rakstu zīmēm. Vektora garums nav ierobežots – tas var būt tikai vienu zīmi liels, vai arī sastāv no ļoti daudz zīmēm vai skaitļiem. Lai nodefinētu vektoru, kas sastāv tikai no vairāk kā viena mainīgā, jāraksta vēlamais objekta (vektora) nosaukums un aiz apzīmējuma &lt;- jāraksta funkcija c(), kurai iekavās norāda mainīgos: Rezultātā izveidotais objekts tiek saglabāts R atmiņā. Lai apskatītu izveidoto objektu, ir jāuzraksta tā nosaukums un jānospiež Enter. pirmais&lt;-c(1,5,7,4,8,10) pirmais ## [1]  1  5  7  4  8 10 otrais&lt;-c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;) otrais ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot;   3.2.4.2 Matrice Matrice ir divdimensionāla datu struktūra, kas līdzīgi vektoram var saturēt tikai viena tipa datus. Matrici var izveidot izmantojot trīs funkcijas: cbind(), rbind() vai matrix(). Funkcijā matrix() norāda visus matricē iekļaujamos elementus, kā arī norāda rindu skaitu (nrow) vai arī kolonnu skaitu (ncol); abus nevajag norādīt, jo, ja ir norādīts, piemēram, kolonnu skaits, tad rindu skaits tiks aprēķināts automātiski, ņemot vērā elementu skaitu matricē: tresais&lt;-matrix(1:15,ncol=3) tresais ##      [,1] [,2] [,3] ## [1,]    1    6   11 ## [2,]    2    7   12 ## [3,]    3    8   13 ## [4,]    4    9   14 ## [5,]    5   10   15 Funkciju cbind() izmanto, lai izveidotu matrici, tās elementus secīgi rakstot kolonnās (iekavās aiz funkcijas jānorāda elementi, kas atradīsies katrā no kolonnām), attiecīgi funkciju rbind() izmanto matrices veidošanai pa rindiņām. ceturtais&lt;-cbind(pirmais,otrais) ceturtais ##      pirmais otrais ## [1,] &quot;1&quot;     &quot;A&quot;    ## [2,] &quot;5&quot;     &quot;B&quot;    ## [3,] &quot;7&quot;     &quot;C&quot;    ## [4,] &quot;4&quot;     &quot;D&quot;    ## [5,] &quot;8&quot;     &quot;E&quot;    ## [6,] &quot;10&quot;    &quot;F&quot; \\subsubsection{Saraksts} Saraksts ir datu struktūras, kas var saturēt jebkuru citu datu struktūru, tai skaitā arī apakšsarakstus. Saraksts ir ļoti ērts, lai vienā objektā apvienu dimensionāli atšķirīgus elementus, piemēram, no vienas analīzes rezultātiem. Sarakstu veido ar funkciju list(). piektais&lt;-list(vekt1=pirmais,matr1=tresais,matr2=ceturtais) piektais ## $vekt1 ## [1]  1  5  7  4  8 10 ##  ## $matr1 ##      [,1] [,2] [,3] ## [1,]    1    6   11 ## [2,]    2    7   12 ## [3,]    3    8   13 ## [4,]    4    9   14 ## [5,]    5   10   15 ##  ## $matr2 ##      pirmais otrais ## [1,] &quot;1&quot;     &quot;A&quot;    ## [2,] &quot;5&quot;     &quot;B&quot;    ## [3,] &quot;7&quot;     &quot;C&quot;    ## [4,] &quot;4&quot;     &quot;D&quot;    ## [5,] &quot;8&quot;     &quot;E&quot;    ## [6,] &quot;10&quot;    &quot;F&quot;   3.2.4.3 Datu tabula Datu tabula ir divdimensionāla datu struktūra, kas var saturēt dažāda tipa datus atsevišķās kolonnās (visām kolonnām vienā datu tabulā ir jābūt ar vienādu garumu). Datu tabulu izveido ar funkciju data.frame(). Funkcijas iekavās norāda kolonnu nosaukumus, kā arī datus, kas būs katrā no kolonnām. Dati var būt kā atsevišķi vektori, kas izveidoti jau iepriekš, vai arī datus var ierakstīt pašā funkcijā: sestais&lt;-data.frame(pirmais,otrais) sestais ##   pirmais otrais ## 1       1      A ## 2       5      B ## 3       7      C ## 4       4      D ## 5       8      E ## 6      10      F septitais&lt;-data.frame(kol1=c(1,2,3,4),kol2=c(5,6,7,8)) septitais ##   kol1 kol2 ## 1    1    5 ## 2    2    6 ## 3    3    7 ## 4    4    8 Vēl datu tabulu var izveidot izmantojot datu tabulu veidotāju pašā programmā R. Šajā gadījumā no sākuma ar kādu Jums vēlamu nosaukumu ir jāizveido datu tabula ar funkciju data.frame(), kurai netiek norādīti nekādi papildus argumenti. Pēc tam jāizmanto funkcija fix(), kurai kā arguments jānorāda jaunās datu tabulas nosaukums. Rezultātā parādīsies datu tabulu veidošanas logs, kurā var ievadīt datus. Lai mainītu kolonnu nosaukumus, ir jāuzklikšķina uz tā - šajā brīdī ir iespējams arī norādīt vai dati būs skaitliski vai rakstu zīmes. Ir jāatceras, ka vienā kolonnā var atrasties tikai viena veida dati, kā arī, ka visu kolonnu garumiem ir jābūt vienādiem. jauna.tabula&lt;-data.frame() fix(jauna.tabula) Ar funkcijas fix() palīdzību ir iespējams labot arī citas jau esošās tabulas.    3.2.5 Datu importēšana R vidē ir iespējams importēt dažāda formāta datu failus (datu tabulas), piemēram, no programmām Excell, SPSS, SAS. Vienkāršākais veids ir izmantot .txt vai .csv failus. Lai importētu .txt failus, tiek izmantota funkcija read.table(), attiecīgi .csv failus var importēt ar funkcijām read.csv() un read.csv2(). Funkcijā norāda faila nosaukumu un ceļu uz to (file=). Ja pirmā tabulas rinda satur kolonnu nosaukumus, tad kā papildus arguments jānorāda header=TRUE. Vēl jānorāda skaitļu decimāldaļu atdalītājs (komats vai punkts), izmantojot papildus argumentu dec=&quot;.&quot;. Tā kā .txt failiem mēdz būt dažādi kolonnu atdalīšanas veidi, tad jānorāda atbilstošais, izmantojot papildus argumentu sep=, iespējamās vērtības ir &quot;\\t&quot; - tab delimited; &quot;,&quot;- kolonnu atdalītājs ir komats; &quot;;&quot; - kolonnu atdalītājs ir semikols. Pilno ceļu uz importējamo failu var nenorādīt, ja fails atrodas darba direktorijā (Working directory) (var nomainīt ar funkciju setwd(). dati&lt;-read.table(file=&quot;niedres.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) dati2&lt;-read.csv(file=&quot;niedres.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) dati3&lt;-read.csv2(file=&quot;niedres.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) dati[1:10,] ##    garums platums ## 1    31.6     2.5 ## 2    23.2     2.3 ## 3    39.2     2.1 ## 4    37.4     5.8 ## 5    21.1     2.2 ## 6    37.0     4.1 ## 7    24.7     3.5 ## 8    31.3     4.2 ## 9    37.4     2.5 ## 10   39.7     2.8 Pašā programmā R ir iekļautas daudzas datu tabulas, kas ir ļoti noderīgas, piemēram, lai izmēģinātu kādas funkcijas, vai arī sekotu līdzi piemēriem mācību materiāliem. Lai redzētu, kuras datu tabulas ir pieejamas konkrētajā darba sesijā (atkarīgs no pievienoto pakešu daudzuma), jāizmanto funkcija data(), pēc kā parādīsies jauns logs, kurā uzskaitītas pieejamās datu tabulas un to apraksts. Lai redzētu visas pieejamās datu tabulas, jāraksta data(package = .packages(all.available = TRUE)). data() data(package = .packages(all.available = TRUE)) Lai pievienotu darba sesijai kādu no šīm datu tabulām, jāizmanto funkcija data(), kurai iekavās norādīts datu tabulas nosaukums. Ja pakete, kurā atrodas šī datu tabula jau ir pievienota darba sesijai, tad papildus argumenti nav vajadzīgi, bet ja pakete nav pievienota, tad funkcijai ir jāliek klāt papildus arguments package=}. Pēc tam datu tabula ir pievienota darba sesijai ar tādu nosaukumu, kāds ir pašai datu tabulai. data(cars) data(cars, package = &quot;datasets&quot;) cars[1:10,] ##    speed dist ## 1      4    2 ## 2      4   10 ## 3      7    4 ## 4      7   22 ## 5      8   16 ## 6      9   10 ## 7     10   18 ## 8     10   26 ## 9     10   34 ## 10    11   17   3.2.6 Datu eksportēšana Datu eksportēšanu veic ar funkciju write.table(), kurā jānorāda objekts, kuru vēlas eksportēt (x=), izveidojamā faila nosaukums un saite uzto (file=), kolonnu atdalītājs (sep=), decimālatdalītājs (dec=) un vai rindu nosaukumus iekļaut (row.names=TRUE vai FALSE). write.table(x=dati,file=&quot;eksports.txt&quot;,row.names=FALSE,sep=&quot;\\t&quot;,dec=&quot;.&quot;)   3.2.7 Darbs ar datiem Ar funkcijas str() palīdzību ir iespējams apskatīt jebkura datu objekta struktūru, tajā ejošos datus un to veidu. Rezultāts ir atkarīgs no tā, kāda veida datu objekts tiek apskatīts. str(dati) ## &#39;data.frame&#39;:    50 obs. of  2 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ... str(sestais) ## &#39;data.frame&#39;:    6 obs. of  2 variables: ##  $ pirmais: num  1 5 7 4 8 10 ##  $ otrais : Factor w/ 6 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 1 2 3 4 5 6 str(piektais) ## List of 3 ##  $ vekt1: num [1:6] 1 5 7 4 8 10 ##  $ matr1: int [1:5, 1:3] 1 2 3 4 5 6 7 8 9 10 ... ##  $ matr2: chr [1:6, 1:2] &quot;1&quot; &quot;5&quot; &quot;7&quot; &quot;4&quot; ... ##   ..- attr(*, &quot;dimnames&quot;)=List of 2 ##   .. ..$ : NULL ##   .. ..$ : chr [1:2] &quot;pirmais&quot; &quot;otrais&quot; str(tresais) ##  int [1:5, 1:3] 1 2 3 4 5 6 7 8 9 10 ... str(otrais) ##  chr [1:6] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; Datu tabulu un matricu apskatīšanai noderīgas ir funkcijas head() un tail(), kas attiecīgi parāda datu objekta pirmās sešas un pēdējās sešas rindiņas. Rindiņu skaitu ir iespējams mainīt, norādot papildus argumentu n=. head(dati) ##   garums platums ## 1   31.6     2.5 ## 2   23.2     2.3 ## 3   39.2     2.1 ## 4   37.4     5.8 ## 5   21.1     2.2 ## 6   37.0     4.1 tail(dati) ##    garums platums ## 45   46.1     5.3 ## 46   29.1     3.5 ## 47   33.7     4.6 ## 48   43.1     3.7 ## 49   38.8     3.9 ## 50   46.9     5.4  3.2.7.1 Daļas no objekta atlasīšana Ja ir nepieciešams atlasīt tikai daļu no objekta, veids kā to darīt ir atkarīgs no objekta veida. Tā kā vektors ir viendimensionāla datu struktūra, tad vien elementa atlsīšanai aiz objekta nosaukuma ir jāliek kvadrtātiskās iekavas, kurās jānorāda atlasāma elementa kārta numurs. otrais[1] ## [1] &quot;A&quot; Vairāku vektora elementu alasīšanai kvadrātiskajās iekavās jāizmanto funkcija c(), kurā norāda atlasāmo elemntu kārtas numurus. otrais[c(1,4)] ## [1] &quot;A&quot; &quot;D&quot; Ja ir nepieciešams atlasīt visus elementu, izņemot kādu konkrētu elementu, tad ‘’nevēlamā’’ elementa kārtas numuru kvadrātiskajās iekavās norāda ar mīnus zīmi. otrais[-3] ## [1] &quot;A&quot; &quot;B&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; No matrices, kas ir divdimensionāla datu struktūra, konkrētu elementu var atlasīt kvadrātiskajās iekavās norādot divus skaitļus, kur pirmais nozīmē rindiņas numuru, bet otrais nozīmē kolonnas numuru. tresais[2,2] ## [1] 7 Ja kvadrātiskajās iekavās norāda tikai vienu skaitli, bet otra vietu atstāj tukšu, tad attiecīgi tiek atlasīta visa rindiņa, vai arī visa kolonna. tresais[1,] ## [1]  1  6 11 tresais[,2] ## [1]  6  7  8  9 10 Elementus no saraksta var atlasīt vairākos veidos, piemēram, rakstot objekta nosaukumu, tad $ zīmi un saraksta elementa nosaukumu. Otrs variants ir izmantot dubultās kvadrātiskās iekavas un norādīt saraksta elementa kārtas numuru. piektais$vekt1 ## [1]  1  5  7  4  8 10 piektais[[2]] ##      [,1] [,2] [,3] ## [1,]    1    6   11 ## [2,]    2    7   12 ## [3,]    3    8   13 ## [4,]    4    9   14 ## [5,]    5   10   15 Ar iepriekšējām divām metodēm no saraksta ir iespējams atlasīt tikai visu elementu. Ja ir nepieciešams atlasīt kaut ko no paša saraksta elementa, tad jāizmanto otras kvadrātiskās iekavas. piektais[[2]][1,] ## [1]  1  6 11 No datu tabulas visu kolonnu var atlasīt tās nosaukumu norādot ar $ zīmes vai arī pēdiņās ierakstot kvadrātiskajās iekavās. sestais$pirmais ## [1]  1  5  7  4  8 10 sestais[&quot;pirmais&quot;] ##   pirmais ## 1       1 ## 2       5 ## 3       7 ## 4       4 ## 5       8 ## 6      10 Viena elementa atlasīšanai ir jāizmanto tāds pats pieraksts kā matricai - kvadrātiskajās iekavās jānorāda divi skaitļis, kas apzīmē rindiņas un kolonnas numuru. sestais[5,1] ## [1] 8 Viena no programmas R specifikām ir tā, ka datu tabulām esošos kolonnu nosaukumus nav iespējams uzreiz izmantot kā mainīgos. Piemēram, ja uzrakstīsim mainīgo garums, kas atrodas pievienotājā datu tabulā dati, parādīsies paziņojums, ka tāda mainīgā nav. R ,veidojot datus tabulas un importējot failus ,katru no kolonnām neuztver kā atsevišķu objektu. garums    3.2.8 Darba vides sakārtošana Ja darba sesijā rada dažādus objektus, pievieno daudz paketes, ar laiku var rasties apjukums par to, kādi objekti šobrīd ir aktīvi. Ar funkcijas ls() palīdzību, ir iespējams iegūt sarakstu ar visiem objektiem, kas šobrīd ir aktīvi: ls() ##  [1] &quot;apaksa&quot;    &quot;augsa&quot;     &quot;cars&quot;      &quot;ceturtais&quot; &quot;dat&quot;       ##  [6] &quot;dati&quot;      &quot;dati2&quot;     &quot;dati3&quot;     &quot;niedr&quot;     &quot;niedres&quot;   ## [11] &quot;otrais&quot;    &quot;piektais&quot;  &quot;pirmais&quot;   &quot;robeza&quot;    &quot;septitais&quot; ## [16] &quot;sestais&quot;   &quot;tests&quot;     &quot;tresais&quot;   &quot;vid.rob&quot;   &quot;videjie&quot;   ## [21] &quot;x&quot; Lai kādu no šiem objektiem noņemtu no darba sesijas, jāizmanto funkcija , kurai kā arguments jānorāda objekts, kuru vēlaties noņemt no darba sesijas. Šī metode gan attiecas tikai uz tiem objektiem, kurus esat radījuši paši, nevis uz datu tabulām, kas atrodas paketēs. rm(pirmais)    "],
["grafiskas-iespejas-programma-r.html", "4. nodaļa. Grafiskās iespējas programmā R 4.1 Pamatgrafiki 4.2 Dati grafiku veidošanai 4.3 Grafiku parametru noteikšana 4.4 Grafiku saglabāšana", " 4. nodaļa. Grafiskās iespējas programmā R Programmā R ir iespējams veidot ļoti augstas kvalitātes grafikus, kuriem ir iespējams definēt jebkuru no interesējošiem parametriem. Grafiku veidošanai ir pieejamas vairākas grafiskās sistēmas, no kurām populārās trīs ir:  Tradicionālie grafiki (Murrell 2006) Trellis jeb Lattice grafiki (Sarkar 2008) ggplot2 grafiki (Wicham 2009)  Šajā grāmatā apskatīti tikai tradicionālo grafiku veidošana.  4.1 Pamatgrafiki Grafikus līdzīgi kā jebkuras citas darbības programmā R veic ar komandu rindām. Ir pieejamas funkcijas, kas izveido jau nodefinētu grafika veidu, vai arī var izveidot grafiku izmantojot atsevišķas funkcijas dažādu parametru definēšanai. R specifika ir tā, ka, izveidojot grafiku, parādās grafiskais logs, kurā ir attēlots konkrētais grafiks. Ja tiek izsaukta jauna funkcija, kas arī veido grafiku, iepriekšējais grafiks tiek aizstāts. Ja ir nepieciešams, ka uz ekrāna vienlaicīgi ir redzami vairāki grafiki, tad pirms katra jauan grafika ir jāraksta funkcija windows() (Windows vidē) vai quartz() (MacOS vidē). Lai veidotu grafiku, ir nepieciešami dati. Šajā nodaļā kā piemērs izmantots datu fails niedres.txt, kas satur informāciju par 50 niedru lapu garumu un platumu. Ar funkciju read.table() fails tiek importēts, pēc tam funkciju str() apskatīta tā struktūra. niedres&lt;-read.table(file=&quot;niedres.txt&quot;,header=T,sep=&quot;\\t&quot;,dec=&quot;.&quot;) str(niedres) ## &#39;data.frame&#39;:    50 obs. of  2 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ...  4.1.1 plot() Visbiežāk pielietotā funkcija grafiku veidošanai ir plot(). Ja šajā funkcijā norāda vienu vai divas skaitļu rindas, tad tā veido izkliedes grafiku (scatterplot) (4.1 attēls). Šai funkcijai ir iespējams norādīt ļoti daudz papildus argumentus, kas maina izveidoto grafiku. Turklāt liekot šajā funkcijā atšķirīgus datus objektu, var iegūt ļoti atšķirīgu rezultātu. plot(niedres$platums)    Figure 4.1: Izkliedes grafika piemērs     4.1.2 boxplot() Funkcija boxplot() izveido Box-plot grafiku (4.2 attēls). Šai funkcijai var norādīt vienu datu rindu, kas satur skaitļus, vai arī divas datu rindas, kur vienā ir skaiļi, bet otrā ir apzīmējumi dalījuma līmeņiem. Otrajā gadījumā attsevišķš Box-plot grafiks tiks izveidots katram no dalījuma līmeņiem. boxplot(niedres$platums)    Figure 4.2: Box-plot grafika piemērs     4.1.3 hist() Ar funkcijas hist() palīdzību ir iespējams izveidot histogrammu datiem, kas vēl nav sagarupēti klasēs (izejas datiem) (4.3 attēls). Šajā funkcijā ir jānorāda tikai viena datu rinda, kuru ir nepieciešams attēlot. Ar papildus argumentiem ir iespējams mainīt to, cik daļās dati tiek dalīti. hist(niedres$platums)    Figure 4.3: Histogrammas piemērs     4.1.4 barplot() Funkcija barplot() veido slokšņu jeb stabiņu grafiku (4.4 attēls). Šī funkcija ir īpaši noderīga gadījumā, ja dati jau ir apkopoti pa klasēm, jo funkcija attēlo datus tādā veidā kā tie norādīti mainīgajā. barplot(niedres$platums)    Figure 4.4: Slokšņu/stabiņu grafika piemērs      4.2 Dati grafiku veidošanai Lai veidotu grafikus, esošos datus no gatavām datu tabulām nav jāsaglabā kā atsevišķus mainīgos -tos uzreiz var izmantot grafiku veidošanai. Ir vismaz trīs dažādi veidi kā norādīt attēlojamos mainīgos: (a) norādot pilnu datu objektu nosaukumu un tad kolonnas nosaukumu, kuru vēlas attēlot; (b) grafika veidošanas funkciju likt kā argumentu funkcijai with(). Visos šajos gadījumos izveidosies līdzīgs attēls (4.1 attēls), var atšķirties tikai paraksti zem asīm. plot(niedres$platums) with(niedres,plot(platums)) Ja ir nepieciešams uz x un y ass attēlot divu mainīgo datus, tad ir divi iespējamie risinājumi: (a) kā pirmo argumentu raksta uz x ass attēlojamo mainīgo, tad komats un uz y ass attēlojamais mainīgais; (b) kā pirmo raksta uz y ass attēlojamo mainīgo, tad tildes zīme ~ un uz x ass attēlojamais mainīgais. Abi varianti izveido identisku grafiku (4.5 attēls). plot(niedres$platums,niedres$garums)    Figure 4.5: Grafiks ar diviem mainīgajiem   plot(niedres$garums~niedres$platums)    Figure 4.6: Grafiks ar diviem mainīgajiem     4.3 Grafiku parametru noteikšana Programmā R grafikiem mainīt paramtrus var divos veidos – izmantojot speciālu funkciju par() vai arī rakstot argumentus iekavās pie citām grafiku veidošanas funkcijām. Funkciju par() lieto, lai noteiktu parametrus, kas ietekmē visus turpmākos grafikus, kāmēr konkrētais grafiskais ekrāns vai vide ir atvērta. Šī funkcija ir jāizsauc kā pirmā pirms grafika veidošanas funkcijas izsaukšanas. Daļu no parametriem var noteikt tikai kopā ar funkciju par().  4.3.1 Grafiku izvietojums lapā R piedāvā iespēju izvietot vienā lapā vairākus attēlus, kas tiek panākts izmantojot argumentus mfrow=, mfcol kopā ar funkciju par(), vai arī izmantojot unkciju layout(). Visi šie argumenti vai funkcija ir jānodefinē pirms grafiku funkcijām, kā arī jāņem vērā tas, ka šīs funkcijas zaudē spēku, ja tiek izmantota funkcija dev.off() vai arī grafiku logs tiek aizvērts. Argumenti mfrow= un mfcol= tiek izmantoti kopā ar funkciju par(), pēc sekojoša principa par(mfrow=c(rinduskaits,kolonnuskaits)). mfrow= un mfcol= atšķirība ir tā, ka pirmajā gadījumā grafiki tiek aizpildīta pēc rindu principa (pirmā rinda, tad otrā rinda), bet otrajā gadījumā aizpilda pēc kolonnu principa (pirmā kolonna, tad otrā kolonna). Funkcija layout() strādā pēc līdzīga principa (4.7 attēls), tikai šajā gadījumā ir iespējams nodefinēt kādā secībā grafiki izvietosies – secīgi vai jauktā veidā, kā arī ar šo funkciju iespējams nodefinēt arī izmērus katram no atsevišķajiem grafikiem. Zemāk minētajā piemērā visas trīs pirmās rindas dod vienādu rezultātu (reāli jāizmanto tikai viena). par(mfrow=c(2,2)) par(mfcol=c(2,2)) layout(matrix(c(1,2,3,4),ncol=2)) plot(niedres$garums) hist(niedres$garums) boxplot(niedres$garums) barplot(niedres$garums)    Figure 4.7: Vairāku grafiku izvietojums vienā lapā   Ja funkcijā layout() kāds no skaitļiem tiek atkārtots, tad grafiks tiks izvietot nevis vienā “rūtiņā”, bet gan divās, kāmēr pārējie grafiki izvietosies vienā rūtiņā (4.8 attēls). layout(matrix(c(1,1,2,3),ncol=2)) plot(niedres$garums) hist(niedres$garums) boxplot(niedres$garums)    Figure 4.8: Vairāku grafiku izvietojums vienā lapā     4.3.2 plot() grafiku tipi Pēc noklusējuma funkcija plot() veido izkliedes grafiku, bet to ir iespējams mainīt norādot papildus argumentu type= iekavās pie šīs funkcijas. Rezultātā var iegūt sešus dažādus grafiku veidus (4.9 attēls). par(mfrow=c(2,3)) plot(niedres$garums,type=&quot;l&quot;,main=&quot;type=\\&quot;l\\&quot;&quot;) plot(niedres$garums,type=&quot;h&quot;,main=&quot;type=\\&quot;h\\&quot;&quot;) plot(niedres$garums,type=&quot;b&quot;,main=&quot;type=\\&quot;b\\&quot;&quot;) plot(niedres$garums,type=&quot;o&quot;,main=&quot;type=\\&quot;o\\&quot;&quot;) plot(niedres$garums,type=&quot;s&quot;,main=&quot;type=\\&quot;s\\&quot;&quot;) plot(niedres$garums,type=&quot;p&quot;,main=&quot;type=\\&quot;p\\&quot;&quot;)    Figure 4.9: Funkcijas plot() grafiku veidi     4.3.3 Līniju parametri Līnijām, kas tiek attēlotas grafikos, ir iespējams nodefinēt vairākus parametrus. Tas tiek panākts ar atsevišķiem argumentiem, kurus lieto kopā ar funkcijām grafika izveidošanai. Pirmais no parametriem, kuru var mainīt, ir līnijas veids. To dara ar argumentu lty=, norādot skaitli no 0 līdz 6 (bez pēdiņām), vai arī lietojot līnijas veida anglisko nosaukumu (attiecīgi “blank”,“solid”, “dashed”, “dotted”, “dotdash”, “longdash”, “twodash”). Ir iespējams nodefinēt arī savu līnijas veidu - pēdiņās aiz lty= jāraksta skaitļi, kur attiecīgi pirmais skaitlis apzīmē līnijas garumu un otrais skaitlis atstarpes garumu (4.10 attēls). Šaja piemērā funkcija lines() tiek izmantota, lai grafikam pievienotu papildus līnijas. Funkcija ir lietojama tikai tad, ja pamatgrafiks jau ir izveidots. x&lt;-rep(10,10) plot(x,type=&quot;l&quot;,lty=1,ylim=c(3,11),axes=F,ann=F,lwd=2) lines(x-1,lty=2,lwd=2) lines(x-2,lty=3,lwd=2) lines(x-3,lty=4,lwd=2) lines(x-4,lty=5,lwd=2) lines(x-5,lty=6,lwd=2) lines(x-6,lty=&quot;664422&quot;,lwd=2) box()    Figure 4.10: Iespējamie līniju tipi grafikos   Lai noteiktu līniju platumu, lieto argumentu lwd=, norādot līnijas biezumu kā skaitli. Līnijas platums būs atkarīgs no tā, kur grafiks tiks attēlots, tas ir, ja grafiku apskatīsies uz ekrāna vai eksportēsiet kā failu, līniju platums var atšķirties. Ar argumentu lend= nosaka kāds būs līnijas nobeigums: apaļš (&quot;round&quot;) vai taisns (&quot;square&quot;&quot; vai &quot;butt&quot;). Arguments ljoin= nosaka kādā veidā līnijas savienojas savā starpā (ja ir lauzta līnija). Savienojums var būt punktveida (&quot;mitre&quot;), apaļš (&quot;round&quot;) un ass leņķis (&quot;bevel&quot;). Attēlā 4.11 var sekot tam, kā mainās līnijas izskats, mainot dažādus tās parametrus (platumu, veidu, savienojumu vietas). layout(matrix(c(1,3,5,2,4,5),ncol=2)) plot(niedres$garums,type=&quot;l&quot;) plot(niedres$garums,type=&quot;l&quot;,lty=4) plot(niedres$garums,type=&quot;l&quot;,lty=4,lwd=12) plot(niedres$garums,type=&quot;l&quot;,lty=4,lwd=12,lend=&quot;butt&quot;) plot(niedres$garums,type=&quot;l&quot;,lty=4,lwd=12,lend=&quot;butt&quot;,ljoin=&quot;bevel&quot;)    Figure 4.11: Līnijas izmaiņas, mainot dažādus parametrus     4.3.4 Simbolu veidi Tradicionālajiem grafikiem ir pieejami 26 iepriekš nodefinēti simbolu veidi datu attēlošanai, kurus var mainīt izmantojot argumentu pch= un norādot skaitli no 0 līdz 25 (4.12 attēls). Papildus ir iespējams norādīt arī burtus vai citus simbolus, tos liekot pēdīņās aiz argumenta pch=. par(mar=c(2,2,1,1)) layout(matrix(1:9,ncol=3)) x&lt;-rnorm(10) plot(x,ann=F) plot(x,pch=0,ann=F) plot(x,pch=5,ann=F) plot(x,pch=8,ann=F) plot(x,pch=12,ann=F) plot(x,pch=17,ann=F) plot(x,pch=23,ann=F) plot(x,pch=&quot;.&quot;,ann=F) plot(x,pch=&quot;A&quot;,ann=F)    Figure 4.12: Simbolu veidi     4.3.5 Virsraksti un teksti pie asīm Virsrakstus un tekstus pie asīm var noteikt gan ar argumentiem, gan ar atsevišķām funkcijām. Kā argumenti (piemēram, funkcijai plot()) nāk xlab= (izveido parakstu zem x ass), ylab= (izveido parakstu zem y ass) un main= (izveido virsrakstu), aiz vienādības zīmes pēdiņās rakstot atbilstošo tekstu (4.13 attēls). plot(niedres$garums,main=&quot;Parastā niedre&quot;,xlab=&quot;Kārtas skaitlis&quot;,ylab=&quot;Lapas garums (cm)&quot;)    Figure 4.13: Grafiks, kuram teksti definēti kā argumenti   Lai varētu ietekmēt vairāk parametrus, tekstus var norādīt arī ar atsevišķām funkcijām, bet šajā gadījumā, piemēram, pie plot() funkcijas jānorāda arguments ann=FALSE, lai programma pati neveidotu parakstus zem asīm. Virsrakstu definē ar funkciju title(), kur pēdiņās raksta nepieciešamo tekstu. Vispārīgā gadījumā tekstus pie asīm nosaka ar funkciju mtext(&quot;ko gribam redzēt&quot;, side=kurā.pusē, line=kurā.līnijā). Izvietojums (puse) atbilst asu izvietojumam (1 - x ass, 2 - y ass, 3 - augšējā ass, 4 - otrā y ass), teksta līnijas rēķina attiecībā pret asīm, tas ir, ja norādīs line=1, tad teksts būs pie pašas ass un, jo lielāks skaitlis, jo tālāk no ass atradīsies teksts (4.14 attēls). plot(niedres$garums,ann=FALSE) title(&quot;Parastā niedre&quot;) mtext(&quot;Kārtas skaitlis&quot;,side=1,line=1) mtext(&quot;Lapas garums (cm)&quot;,side=2,line=3)    Figure 4.14: Grafiks, kuram teksti definēti kā atsevišķas funkcijas     4.3.6 Teksts grafika iekšienē a nepieciešams izvietot tekstu grafika iekšienē, ir jāizmanto funkcija text(). Šai funkcijai kā argumentus jānorāda x un y koordinātes (atbilstoši asu skalām), kur jānovieto teksts un jānorāda pats teksts, kuru vēlas ievietot. Ir jāņem vērā, ka pēc noklusējuma teksts tiks izveitots tā, ka norādītās koordinātes ir teksts viduspunkts. Lai to mainītu, ir jānorāda papildus arguments pos= ar iespējamām vērtībām: 1 - teksts atrodas zem šī punkta; 2 - teksts atrodas pa kreisi no šī punkta; 3 - teksts atrodas virs šī punkta; 4 - teksts atrodas pa labi no šī punkta. Ja tekstam vajag mainīt orientāciju (lai tas nebūtu novietots horizontāli), jāizmanto papildus arguments srt=, kuram jānorāda teksta novietojums grādos. Piemērā grafikā (4.15 attēls) ir izvietoti divi uzraksti: &quot;pirmais&quot; - bez papildus argumentiem; &quot;otrais&quot; - novietots virs koordināšu punkta un 25 grādu slīpumā. plot(niedres$garums) text(20,20,&quot;pirmais&quot;) text(40,40,&quot;otrais&quot;,pos=3,srt=25)    Figure 4.15: Tekstu novietojuma piemērs     4.3.7 Tekstu parametri Tekstam var definēt dažādus parametrus, no kuriem svarīgākie būtu fonts, fontu grupa un burtu izmērs. Nosakot fontu, jānosaka kādai fontu grupai tas piederēs ar argumentu family=. Fontu grupas ir, piemēram, &quot;mono&quot;, &quot;serif&quot;, &quot;sans&quot;. Fontu tipu nosaka ar argumentu font= ar iespējamo vērību no 1 līdz 5, kur 1 apzīmē parastus burtus, 2 - bold, 3 - italic, 4 – bold italic un 5 - simboli. Argumentu family= var lietot tikai kopā ar funkciju par(), bet font= var izmantot kopā arī ar citām funkcijām. Lai definētu fonta tipu asīm, asu parakstiem un virsrakstiem, attiecīgi var lietot argumentus font.axis=, font.lab= un font.main=. Burtu izmēru var noteikt ar diviem argmentiem ps= un cex=. Arguments ps= nosaka absolūto burtu izmēru punktos. cex= nosaka relatīvo burtu izmēru, piemēram, cex=1.5 nozīmēs, ka burtiem ir jābūt 1.5 reizes lielākiem nekā ir standarta izmēra burti. ps= lieto tikai kopā ar par(), bet cex= var izmantot kopā arī ar citām funkcijām. cex.axis=, cex.lab= un cex.main= attiecīgi izmanto, lai apzīmētu asu simbolu, asu parakstu un virsrakstu relatīvo izmēru. Piemērā (4.16 attēls) ir izmainīti izmēri virsrakstiem, parakstiem un skaitļiem pie asīm, kā arī katram no šiem parametriem ir izmantots cits fonta tips. plot(niedres$garums,main=&quot;Parasta niedre&quot;,xlab=&quot;Kartas skaitlis&quot;,      ylab=&quot;Lapas garums (cm)&quot;,cex.main=3,cex.lab=1.5,cex.axis=0.8,      font.main=3,font.axis=4,font.lab=2)    Figure 4.16: Teksta parametru izmaiņas     4.3.8 Asis Ja ir nepieciešams noteikt asu garumu (to ierobežojot kādā intervālā, vai arī tieši otrādi - padarot asi garāku, nekā tā tiek automātiski veidota) (4.17 attēls), var izmantot argumentus xlim= un ylim=, ko lieto, piemēram, ar funkciju plot(). Abiem argumentiem pieraksts ir vienāds xlim=c(sākuma.vērtība,beigu.vērtība). par(mfcol=c(1,2)) plot(niedres$garums) plot(niedres$garums,xlim=c(10,40),ylim=c(-10,80))    Figure 4.17: Asu garuma izmaiņu piemērs   Ja grib ietekmēt vairākus ass parametrus, tad jāizmanto funkcija axis(), bet pirms tam, piemēram, kā arguments pie plot(), jāraksta axes=FALSE, lai programma automātiski pati neveidotu asis. Funkcijas pieraksts ir axis(kura.ass, at=seq(sākuma.vērtība,beigu.vērtība,intervāls), labels=c(ko.attēlot)). Asu numerācija ir sekojošā: apakšējā ir 1, kreisā ir 2, augšējā 3 un labā ir 4. Ja argumentu labels= nenorāda, tad tiek attēloti tie paši skaitļi, kas ir pie argumenta at=. Ar argumentu las= var mainīt skaitļu/tekstu novietojumu pie ass, kur 0 nozīmē parallēls asij, 1 - horizontāls, 2 - perpendikulārs asij, 3 - vertikāls. Piemērā (4.18 attēls) x asij nodefinēts, ka skaitļiem pie ass jābūt no 0 ik pēc 15, toties y asij pie skaitļiem 20, 40 un 60 ir jāparādas tekstam, nevis skaitļiem. par(mfcol=c(1,2)) plot(niedres$garums) plot(niedres$garums,axes=FALSE) axis(1,at=seq(0,50,15),las=2) axis(2,at=c(20,40,60),labels=c(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;),las=1) box()    Figure 4.18: Asu definēšanas piemērs     4.3.9 Divas y asis Lai arī daļa speciālistu atzīst, ka grafiki ar y asīm nav labi, reizēm tādus ir nepieciešamas izveidot. Pirmkārt, ar funkciju par() un argumentu mar= jāizmaina malu izmēri, lai otrai y asij būtu vietas. Pēc tam jāuzzīmē pamatgrafiks, aiz kura nāk funkcija par(new=TRUE), kas ļauj pa “virsu” zīmēt otru grafiku. Otrajam grafikam jālieto argumenti axes=FALSE un ann=FALSE, lai apzīmējumi nepārklātos. Tālāk jau ar funkcijām axis() un mtext() iegūst vēlamos apzīmējumus pie atbilstošās ass (4.19 attēls). par(mar=c(5,5,2,5)) plot(niedres$garums,type=&quot;l&quot;) par(new=TRUE) plot(niedres$platums,type=&quot;l&quot;,lty=3,axes=F,ann=F) axis(4,at=seq(0,8,2)) mtext(side=4,line=2,&quot;platums&quot;)    Figure 4.19: Grafiks ar divām y asīm     4.3.10 Krāsas Ir iespējams mainīt krāsas visām grafika sastāvdaļām, izmantojot dažādus argumentus (4.20 attēls). Šos argumentus var rakstīt kā daļu no funkcijas par() un šajā gadījumā krāsas būs noteiktas visiem grafikiem, vai arī lietot kā daļu, piemēram, no funkcijas plot() un šajā gadījumā krāsas mainīsies tikai konkrētajam grafikam. Vieglākais veids kā apzīmēt krāsu, ir lietot tās anglisko nosaukumu, piemēram, &quot;red&quot; vai &quot;darkgreen&quot;. Lai redzētu visu pieejamo krāsu nosaukumus, jāraksta komanda colors(). Pamatā ir trīs argumenti krāsu maiņai: col=, bg= un fg=. col=&quot;krāsas.nosaukums&quot; ir visbiežāk lietotais krāsas parametrs, ar kuru pārsvarā tiek noteikta datu simbolu, līniju, tekstu un citu sastāvdaļu, kas atrodas grafikā krāsa. Lai noteiktu asu, asu parakstu, virsrakstu un apakšvirsrakstu krāsas, jālieto attiecīgi argumenti col.axis=, col.lab=, col.main= un col.sub=. fg=&quot;krāsas.nosaukums&quot; izmanto, lai mainītu asu un grafika malu krāsu, un daļēji tas sakrīt ar col.axis= un col.main= argumentiem. bg=&quot;krāsas.nosaukums&quot; nosaka fona krāsu, šo argumentu var lietot kopā tikai ar funkciju par(). par(bg=&quot;lightblue&quot;) plot(niedres$garums,fg=&quot;red&quot;,main=&quot;Slikts grafiks&quot;,col.main=&quot;green&quot;,col.axis=&quot;yellow&quot;)    Figure 4.20: Krāsu izmantošanas piemērs     4.3.11 Leģenda Tradicionālajiem grafikiem leģendas programmā R veido ar atsevišķu funkciju legend(). Leģenda parasti ir novietota grafika iekšējā daļā (4.21 attēls). Dotajai funkcijai kā argumentus jānorāda: (a) leģendas novietojums - to nosaka ar x un y koordināti leģendas rāmīša augšējam kreisajam stūrim (koordinātes nosaka atbilstoši asu vērtībām, piemēram, ja uz x ass vērtības ir robežās no 5 līdz 10, bet uz y ass no 100 līdz 200, tad leģenas koordināte varētu būt 6 un 125); (b) nosaukumi, kuriem jāparādās leģendā; (c) datu simbolu/līniju veidu apzīmējumi (tiem ir jāsakrīt ar apzīmējumiem, kas izmantoti, lai definētu grafiku). par(mar=c(5,5,2,5)) plot(niedres$garums,type=&quot;l&quot;) par(new=TRUE) plot(niedres$platums,type=&quot;l&quot;,lty=3,axes=F,ann=F) axis(4,at=seq(0,8,2)) mtext(side=4,line=2,&quot;platums&quot;) legend(0,7,lty=c(1,3),c(&quot;garums&quot;,&quot;platums&quot;))    Figure 4.21: Grafiks ar leģendu     4.3.12 Līnijas grafikos Ja grafikā ir nepieciešams izvietot taisnu līniju, var izmantot funkciju abline(). Ja ir nepieciešams uzzīmēt slīpu līniju, tad ir jānorāda divi skaitļi, kas attiecīgi norāda puktu, kurā līnija krusto x asi un līnijas slīpumu (intercept), vai arī jāizmanto papildus funkcija lm(), kas izveidos regresijas līkni grafikā attēlotajiem mainīgajiem (4.22 attēls). Ja nepieciešams izveidot horizontālas līnijas, tad jānorāda arguments h= un vērtības (viena vai vairākas), kurās vietās horizontālās līnijas krustos y asi. Attiecīgi vertikālām līnijām ir jānorāda arguments v=. plot(niedres$garums~niedres$platums) abline(lm(niedres$garums~niedres$platums)) abline(h=c(30,40),lty=c(2,3)) abline(v=c(3,5),col=&quot;grey55&quot;)    Figure 4.22: Grafiks ar papildus līnijām      4.4 Grafiku saglabāšana Programmā R iegūtos grafikus ir iespējams saglabāt dažādos formātos, izmantošanai citās programmās. Jau izveidotu grafiku, kas redzams uz ekrāna, ir iespējams saglabāt izmantojot opciju File/Save as... un izvēloties nepieciešamo faila veidu (Metafile, Postcript, PDF, Png, Bmp, Jpeg (kvalitāte 50%, 75% vai 100%), kā arī grafiku ir iespējams ielikt atmiņa File/Copy to clipboard... Saglabājot jau izveidotu grafiku, ir jāņem vērā, ka uz ekrāna grafiks ne vienmēr tiek attēlots pareizākajās proporcijās, sevišķi, ja ekrāna izmērus esat pielāgojuši paši. Grafikus ir iespējams uzreiz saglabāt nepieciešamajā formātā ar atbilstošu komandu rindu, tikai šajā gadījumā grafiks netiks parādīts uz ekrāna. Lai grafikus uzreiz saglabātu, pirms visām komandu rindām, ar kurām nosaka grafika parametrus, ir jāraksta atbilstoša komanda, kas nosaka saglabājamā faila formātu un faila nosaukumu: postscript(file=&quot;nosaukums.ps&quot;) png(file=&quot;nosaukums.png&quot;) pdf(file=&quot;nosaukums.pdf&quot;) jpeg(file=&quot;nosaukums.jpg&quot;) bmp(file=&quot;nosaukums.bmp&quot;) Pēc tam, kad ir uzrakstītas visas vajadzīgās grafika komandu rindas, ir “jāatslēdz” komanda, ar kuru noteica faila formātu un faila nosaukumu. Pretējā gadījumā visi nākamie grafiki arī tiks saglabāti konkrētajā failā, aizstājot iepriekšējo. Lai to izdarītu, raksta komandu dev.off().   "],
["datu-izzinasana-un-normalitates-testi.html", "5. nodaļa. Datu izzināšana un normalitātes testi 5.1 Datu izzināšana 5.2 Normalitātes testi", " 5. nodaļa. Datu izzināšana un normalitātes testi  5.1 Datu izzināšana Pirms uzsākt reālu datu analīzi, veicot dažādus statistiskos testus, vienmēr vajag sākotnējo datu izzināšanu, izmantojot dažādus datu grafiskos attēlojumus. Tādējādi ir iespēja jau pirms statistisko analīžu veikšanas novērtēt vai datos redzamas kādas tendences, savstarpējās saistības, grupēšanās, kā arī secināt vai datos nav kādas dīvainas, neiederīgas vērtības. Kā piemērs izmantots datu fails niedres2.txt, kas satur informāciju par niedru lapu garumu un platumu trīs parauglaukumos. niedr&lt;-read.table(file=&quot;niedres2.txt&quot;,header=T,sep=&quot;\\t&quot;,dec=&quot;.&quot;) str(niedr) ## &#39;data.frame&#39;:    50 obs. of  3 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ... ##  $ paraug : Factor w/ 3 levels &quot;Austr&quot;,&quot;Riet&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Vienkāršākais grafiks datu apskatīšanai ir izkliedes grafiks, ko programmā R var iegūt ar funkciju plot(). Šajā grafikā (5.1 attēls) uz x ass atlikts novērojuma kārtas numurs, uz y ass novērojumu vērtības. Pēc izkliedes grafika var gūt priekštatu par vērtību izkliedi, gan arī novērtēt vai nav kādas ekstremāli mazas vai lielas vērtības. plot(niedr$garums)    Figure 5.1: Viena mainīgā izkliedes grafiks   Ja funkcijā plot() norāda divus mainīgos, tad vienlaicīgi var novērtēt gan šo mainīgo vērtību saistību (5.2 attēls), gan arī pamanīt kādus ekstrēmus, ko nav iespējams novērtēt skatot katru mainīgo atsevišķi. plot(niedr$garums,niedr$platums)    Figure 5.2: Divu mainīgo izkliedes grafiks   Box-plot grafiki, ko iegūst ar funkciju boxplot(), ir piemēroti, lai novērtētu vērtību izkliedi datos (5.3 attēls). Box-plot grafikā līnija, kas atrodas taisntūra vidū, atbilst mediānai, taisnstūra apakšējā un augšējā mala attiecīgi ir 1. un 3. kvartile. Apakšējā un augšējā līnija attiecīgi ir minimālā un maksimālā vērtība datos, ar piebildi, ka šīs līnijas neatrodas tālāk kā 1,5 reiz taisntūra platums (attālums starp 1. un 3. kvartili). Ja minimālā vai maksimālā vērtība ir tālāk nekā šīs 1,5 reizes, tad šos novērojumus apzīmē ar punktu. boxplot(niedr$garums)    Figure 5.3: Box-plot grafiks vienam mainīgajam   Ja funkcijā {boxplot() norāda mainīgo, kas satur dalījumu līmeņos, tad atsevišķš grafiks tiek izveidots katram no dalījuma līmeņiem (5.4 attēls). Pēc šī grafika var salīdzināt datu izkliedi uzreiz vairākiem līmeņiem. boxplot(niedr$garums~niedr$paraug)    Figure 5.4: Box-plot grafiks trīs paraugkopām   Gadījumos, kad novērojumu skaits ir salīdzinoši mazs, tad labāk datu izkliedi raksturo punktu grafiks (5.5 attēls), ko var iegūt ar funkciju stripchart(). Šajā grafikā katrs novērojums ir attēlots ar kvadrātiņi un visi novērojumi izkārtoti vienā strīpā. stripchart(niedr$garums)    Figure 5.5: Punktu grafiks   Ja novērojumi pārklājas un nav iespējams precīzi attēlā novērtēt, cik daudz novērojumu atbilst katrai vērtībai, funkciju stripchart() var papildināt ar argumentu method=&quot;stack&quot;, kas novietot kvadrātiņus blakus, ja tie pilnībā pārklājas (5.6 attēls). Arguments vert=T nodrošina, ka grafiks novietojas vertikāli, nevis horizontāli. stripchart(niedr$garums,method=&quot;stack&quot;,vert=T)    Figure 5.6: Modificēts punktu grafiks   Vēl viens plaši izmantots datu attēlošanas veids ir histogramma, ko programmā R var izveidot ar funkciju hist(). Histogrammā dati tiek sadalīti klasēs un tādējādi var novērtēt vērtību sadalījuma veidu - vienmērīgi, zvanveidīgi, ar izteiktām minimālām vai maksimālām vērtībām (5.7 attēls). Funkcijai var mainīt argumentus gan nosakat cik klasēs dalīt datus, gan arī nosakot tieši dalījuma robežas. hist(niedr$garums)    Figure 5.7: Pazīmes niedru lapu garums histogramma     5.2 Normalitātes testi  5.2.1 Grafiskā analīze Daudzu statistisko metožu pieņēmums ir, ka analizējamie dati nāk no ģenerālkopas, kura atbilst normālajam sadalījumam. Lai par to pārliecinātos, ir jāveic noteikti statistiskie testi. Jaunākajā statistiskajā literatūrā arvien biežāk kā pamatmetode normalitātes novērtēšanai tiek izmantota grafiskā analīzē, nevis analītiskie testi. Viens no grafiku veidiem, ko izmantot normalitātes novērtēšanai, var būt histogramma (5.7 attēls). Histrogrammai ir jāveido apmēram zvanveidīgs izskats, lai pieņemtu, ka dati atbilst normālajam sadalījumam. Ar šo grafiku veidu problēma ir tā, ka histogrammas izskats lielā mērā būs atkarīgs no tā, cik klasēs dati ir sadalīti. Uzticamāks grafika veids ir tā saukti QQ grafiki, kas attēlo attiecību starp reālo datu kvantilēm un teorētisko datu kvantilēm (teorētiskie dati veidoti balstoties uz reālo datu statistiskajiem rādītājiem tā, lai tie atbilstu normālajam sadalījumam). Ja reālie dati atbilst normālajam sadalījumam, tad grafikā visi punkti novietojas uz diagonāles. Programmā R QQ grafiku veido ar funkciju qqnorm(), kurai kā argumentu norāda reālos datus. Papildus var izmantot arī funkciju qqline(), kas novelk līniju, lai būtu vieglāk interpretēt rezultātus. Iegūtajā grafikā (5.8 attēls) ideālā gadījumā visiem punktiem būtu jāatrodas uz taisnes, bet nelielas novirzes arī ir akceptējamas. Lai iemācītos strādāt ar šādiem grafikiem, var ģēnerēt mākslīgus datus no normālā sadalījuma un skatīties kā kātreiz izskatās QQ grafiks. qqnorm(niedr$garums) qqline(niedr$garums)    Figure 5.8: QQ grafiks niedru lapu garumam   Paketē car ir funkcija qqPlot(), kas arī veido QQ grafiku, tikai tas ir papildināts ar līnijām, kas parāda 95% ticamības intervālu (5.9 attēls), tādējādi atvieglojot interpretāciju. Ja visi punkti atrodas starp raustītajām līnijām, tad ar 95% pārliecību var apgalvot, ka dati nāk no ģenerālkopas, kas atbilst normālajm sadalījumam. library(car) qqPlot(niedr$garums)    Figure 5.9: Modificēts QQ grafiks niedru lapu garuma     5.2.2 Analītiskā analīze Ja ir nepieciešams daudz formālāks veids kā novērtēt datu atbilstību normālajam sadalījumam, var izmantot kādu no analītiskajām metodēm. R bāzes versijā ir pieejams Šapiro-Vilka normalitātes tests, ko var iegūt ar funkciju shapiro.test(). Funkcijai kā arguments jānorāda tikai mainīgais, kuram veikt normalitātes testu. Nulles hipotēze par to, ka dati atbilst normālajam sadalījumam nebūs noraidīta, ja iegūtā p-vērtība būs lielāka par izvēlēto būtiskuma līmeni. shapiro.test(niedr$garums) ##  ##  Shapiro-Wilk normality test ##  ## data:  niedr$garums ## W = 0.99101, p-value = 0.9668 Secinājums: pie būtiskuma līmeņa \\(\\alpha=0,05\\) pazīmes niedru lapu garums vērtības atbilst normālajam sadalījumam, jo p-vērtība ir lielāka par noteikto būtiskuma līmeni (0,97&gt;0,05). Funkciju shapiro.test() var izmantot arī kopā ar funkciju tapply(), tādējādi veicot šo testu vairākiem dalījuma līmeņiem uzreiz. tapply(niedr$garums,niedr$paraug,shapiro.test) ## $Austr ##  ##  Shapiro-Wilk normality test ##  ## data:  X[[i]] ## W = 0.8863, p-value = 0.04028 ##  ##  ## $Riet ##  ##  Shapiro-Wilk normality test ##  ## data:  X[[i]] ## W = 0.94264, p-value = 0.3508 ##  ##  ## $Ziem ##  ##  Shapiro-Wilk normality test ##  ## data:  X[[i]] ## W = 0.90337, p-value = 0.09103 Secinājums: pie būtiskuma līmeņa \\(\\alpha=0,05\\) pazīmes niedru lapu garums vērtības atbilst normālajam sadalījumam Rietumu un Ziemeļu parauglaukumos, jo p-vērtības ir lielākas par noteikto būtiskuma līmeni (0,35&gt;0,05 un 0,09&gt;0,05), toties Austrumu parauglaukuma dati neatbilst normālajam sadalījumam, jo p-vertība ir mazāka par noteikto būtiskuma līmeni (0,04&lt;0,05). Programmā R ir pieejama pakete nortest, kurā ir apvienoti pieci dažādi normalitātes testi, piemēram, Andersona-Darlinga tests un Lilliefora (Kolmogorova-Smirnova) tests. Testi savā starpā atšķiras ar algoritmiem kādā veidā salīdzina reālos datus ar teorētiski sagaidāmajiem, attiecīgi arī iegūtās p-vērtības starp testiem mēdz atšķirties. Daļa no testiem ir striktāki, daļa mazāk strikti. library(nortest) ad.test(niedr$garums) ##  ##  Anderson-Darling normality test ##  ## data:  niedr$garums ## A = 0.17373, p-value = 0.9223    "],
["statistiskie-raditaji-un-ticamibas-intervali.html", "6. nodaļa. Statistiskie rādītāji un ticamības intervāli 6.1 Statistiskie rādītāji 6.2 Ticamības intervāli", " 6. nodaļa. Statistiskie rādītāji un ticamības intervāli  6.1 Statistiskie rādītāji  6.1.1 Teorētiskais pamatojums Paraugkopas un ģenerālkopas raksturošanai un informācijas apkopošanai izmanto statistiskos rādītājus. Tos iedala vairākās grupās, no kurām svarīgākās ir vidējie rādītāji un izkliedes radītāji.  6.1.1.1 Vidējie rādītāji Vidējie rādītāji parāda kāda ir vidējā vērtība paraugkopas datiem katrai konkrētajai pazīmei.   6.1.1.2 Vidējais aritmētiskais (\\(\\overline{x}\\)) Visbiežāk lietotais vidējais rādītājs ir vidējais aritmētiskais, kas, atbilstoši tā nosaukumam, parāda kāda ir vidēja vērtība. Tā aprēķināšanu veic pēc formulas (\\ref{eq:vvarit}): \\begin{equation} \\overline{x}=\\frac{\\sum\\limits_{i=1}^{n}x_i}{n} \\label{eq:vvarit} \\end{equation} kur \\(x_i\\) - i-tā paraugkopas vērtībā, i=1, 2, …, n, n - paraugkopas apjoms. Attiecībā uz vidējo aritmētisko ir jāņem vērā, ka tā vērtība ir atkarīga no katras variantes datos, tāpēc vidējais aritmētiskais ir jutīgs pret ekstremāli mazām vai lielām vērtībām. Piemēram, ja datos ir viena ļoti liela vērtība, tad ir iespējama situācija, ka vidējais aritmētiskais ir mazāks tikai par šo ekstremāli lielo vērtību, bet lielāks par visām pārējām vērtībām.   6.1.1.3 Mediāna (\\(M_e\\)) Mediāna ir tā konkrētās paraugkopas vērtība līdz kurai atrodas 50% no visām vērtībām (ja tās sakārtotas augošā vai dilstošā secībā). Piemēram, ja paraugkopā ir nepāra skaits novērojumu, pieņemsim, pieci, tad mediāna būs trešā vērtība. Ja paraugkopā ir pāra skaits novērojumu, pieņemsim seši, tad mediāna būs vidējais aritmētiskais starp trešo un ceturto vērtību. Atšķirībā no vidējā aritmētiskā, mediāna nav jutīga pret ekstremālām vērtībām, jo tās aprēķins balstās uz vērtību izkārtojumu, nevis uz to absolūtajām vērtībām.   6.1.1.4 Kvartiles (\\(Q_i\\)) Kvartiles augošā/dilstošā secibā sakārtotas paraugkopas vērtības sadala četrās vienādās daļās. 0. kvartile atbilst minimālajai vērtībai, līdz 1. kvartilei atrodas 25% no visiem novērojumiem,līdz 2. kvartilei atrodas 50% novērojumu un tā ir vienāda ar mediānu. Līdz 3. kvartilei atrodas 75% no visiem novērojumiem, un 4. kvartile ir vienāda ar maksimālo vērtību.   6.1.1.5 Procentile (\\(P_i\\)) Procentiles augošā/dilstošā secībā sakārtotas paraugkopas vērtības sadala 100 vienādās daļās.   6.1.1.6 Izkliedes rādītāji Vidējie rādītāji sniedz informāciju par vidējo tendenci datos, bet, lai iegūtu pilnu ainu par datiem, ir jāizmanto arī izkliedes rādītāji, kas parāda kādā veidā paraugkopas vērtības ir izkliedētas ap vidējo vērtību.   6.1.1.7 Standartnovirze (s) un dispersija (\\(s^2\\)) Svarīgākie izkliedes rādītāji ir dispersija un standartnovirze. Dispersiju paraugkopai aprēķina pēc formulas (\\ref{eq:disneg}) un tā parāda, kāda ir vidējā kvadrātiskā novirze no vidējā aritmētiskā. Standartnovirze (\\ref{eq:stand}) attiecīgi ir kvadrātsakne no dispersijas. Standartnovirzei ir tāda paša mērvienība kā paraugkopas datiem. Jo lielākas ir dispersijas un standartnovirzes vērtības, jo lielāka ir datu izkliede ap vidējo aritmētisko. \\begin{equation} s^2=\\frac{\\sum\\limits_{i=1}^{n}(x_i-\\overline{x})^2}{n-1} \\label{eq:disneg} \\end{equation}\\begin{equation} s=\\sqrt{\\frac{\\sum\\limits_{i=1}^{n}(x_i-\\overline{x})^2}{n-1}} \\label{eq:stand} \\end{equation} kur \\(x_i\\) - i-tā paraugkopas vērtībā, i=1, 2, …, n, n - paraugkopas apjoms, \\(\\overline{x}\\) - paraugkopas vidējais aritmētiskais.   6.1.1.8 Variācijas koeficients (v) Standartnovirze ne vienmēr ir labākais rādītājs, lai salīdzinātu vērtību izkliedi starp dažādiem rādītājiem, sevišķi, ja tiem atšķiras mērvienības. Šajā gadījumā labāks rādītājs ir variācijas koeficients (\\ref{eq:varkoe}). Variācijas koeficients ir rādītājs bez mērvienības, jo to iegūst dalot standartnovirzi ar vidējo aritmētisko. Variācijas koeficientu var izteikt arī procentos, attiecīgi sareizinot tā vērtību ar 100%. \\begin{equation} v=\\frac{s}{\\overline{x}} \\label{eq:varkoe} \\end{equation} kur s - paraugkopas standartnovirze, \\(\\overline{x}\\) - paraugkopas vidējais aritmētiskais.    6.1.2 Statistisko rādītāju aprēķināšana programmā R Piemēram par statistisko rādītāju aprēķināšanu izmantot datu fails niedres2.txt, kas satur informāciju par niedru lapu garumu un platumu trīs parauglaukumos. niedr&lt;-read.table(file=&quot;niedres2.txt&quot;,header=TRUE,sep=&quot;\\t&quot;,dec=&quot;.&quot;) str(niedr) ## &#39;data.frame&#39;:    50 obs. of  3 variables: ##  $ garums : num  31.6 23.2 39.2 37.4 21.1 37 24.7 31.3 37.4 39.7 ... ##  $ platums: num  2.5 2.3 2.1 5.8 2.2 4.1 3.5 4.2 2.5 2.8 ... ##  $ paraug : Factor w/ 3 levels &quot;Austr&quot;,&quot;Riet&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Pamatstatistisko rādītāju aprēķināšanai ir jau definētas funkcijas: mean() - vidējais aritmētiskais, sd() - standartnovirze, var() - dispersija, median() - mediāna. Visām šīm funkcijām kā mainīgais jānorada viena kolonna/vektors un tiks aprēķināts vēlamais rādītājs. mean(niedr$garums) ## [1] 37.594 sd(niedr$garums) ## [1] 10.31332 var(niedr$garums) ## [1] 106.3647 median(niedr$garums) ## [1] 38.4 Veicot aprēķinus rezultātam ciparu skaits aiz komata ir atkarīgs no tā, kādi ir sesijas uzstādījumi. Ja ir nepieciešams noapaļot skaitļus, var izmantot papildus funkciju round(), kurā norāda apaļojamo mainīgo vai visu funkciju, kā arī jānorāda vēlamais ciparu skaits aiz komata. Ir jāatceras, ka noapaļot drīkst tikai gala rezultātus - ja noapaļo skaitļus, kurus vēlāk izmanto citos aprēķinos, tas samazina iegūtā rezultāta precizitāti. round(mean(niedr$garums),2) ## [1] 37.59 Viena no daudzu programmas R funkciju īpatnībām ir tā, ka nav iespējams iegūt rezultātu, ja dati satur kādu iztrūkstošu vērtību. Piemēram, radam vektoru x, kas satur 20 skaitļus no normālā sadalījuma un vienu iztrūkstošu vērtību, ko R apzīmē ar NA. Ja šādam vektoram cenšas aprēķināt vidējo aritmētisko ar funkciju mean(), iegūst rezultātu NA, jo nezināmā vērtība var būt jebkas, attiecīgi arī vidējais var būt jebkas. set.seed(1234) x&lt;-c(rnorm(20),NA) mean(x) ## [1] NA Šādā situācijā var norādīt, ka NA vērtības ir jāignorē. To panāk funkcijai kā papildus argumentu norādot na.rm=TRUE. Daļai funkciju šī argumenta pieraksts var būt atšķirīgs, to var precizēt funkcijas aprakstā. mean(x,na.rm=TRUE) ## [1] -0.2506641 Minimālās un maksimālās vērtības aprēķināšanai var izmantot attiecīgi funkcijas min() un max(), vai arī funkciju range(), kas aprēķina uzreiz abus šos rādītājus. min(niedr$garums) ## [1] 11.9 max(niedr$garums) ## [1] 59 range(niedr$garums) ## [1] 11.9 59.0 Kvartiļu aprēķināšanai izmanto funkciju quantile(), kas pārādīs uzreiz visas kvartiles tās izsakot kā procentiles. quantile(niedr$garums) ##     0%    25%    50%    75%   100%  ## 11.900 31.075 38.400 45.300 59.000 Ja ir nepieciešams aprēķināt procentiles, vai arī tikai kādu noteiktu kvartili, funkcijai quantile() kā papildus arguments jānorāda probs= un nepieciešamā procentile izteikta decimāldaļās. quantile(niedr$garums,probs=c(0.025,0.975)) ##   2.5%  97.5%  ## 18.465 55.770 Ar funkciju summary() ir iespējams aprēķināt uzreiz vairākus statistiskos radītājus, kas raksturo mainīgo. Šie rādītāji ir minimālā vērtība, 1. kvartile, mediāna, vidējais aritmētiskais, 3. kvartile un maksimālā vērtība. Šai funkcijai kā mainīgo var norādīt vienu kolonnu vai vektoru. summary(niedr$garums) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   11.90   31.08   38.40   37.59   45.30   59.00 Ja funkcijā summary() kā mainīgo norāda veselu datu tabulu, tad iepriekš minētie rādītāji tiek aprēķināti katrai kolonnai, kas satur skaitlisku informāciju. Kolonnai, kas satur faktoru jeb tekstuālu informāciju, aprēķina cik bieži atkārtojas katra unikālā vērtība. summary(niedr) ##      garums         platums        paraug   ##  Min.   :11.90   Min.   :0.400   Austr:17   ##  1st Qu.:31.07   1st Qu.:2.500   Riet :17   ##  Median :38.40   Median :3.900   Ziem :16   ##  Mean   :37.59   Mean   :3.892              ##  3rd Qu.:45.30   3rd Qu.:5.100              ##  Max.   :59.00   Max.   :7.100 Funkcija tapply() ir ļoti noderīga gadījumos, ja nepieciešams aprēķināt kādu rādītāju viena vektora/kolonnas vērtībām tās sadalot pa līmeņiem, kurus nosaka otrs vektors/kolonna. Funkcijā jānorāda mainīgais, kas satur vērtības, mainīgais, kas satur dalījuma līmeņus, un funkcija, kuru izmantot aprēķinos. Ir iespējams izmantot ne tikai jau definētas funckijas, bet arī definēt jaunas funkcijas, izmantojot function() funkciju. Piemērā aprēķināta standartnovirze kolonnai garums, ka sadalīta pa parauglaukumiem. tapply(niedr$garums,niedr$paraug,sd) ##     Austr      Riet      Ziem  ##  8.869876  9.376174 11.706401    6.2 Ticamības intervāli  6.2.1 Teorētiskais pamatojums Veicot pētījumus vairumā gadījumu tiek strādāts ar paraugkopu, nevis ar visu ģenerālkopu. Attiecīgi no paraugkopas datiem iegūtais, piemēram, vidējais aritmētiskais nebūs vienāds ar ģenerālkopas vidējo aritmētisko, kaut arī daudzos gadījumos tas tā tiek pieņemts. Precīzākai ģenerālkopas vērtējamā rādītāja raksturošanai var izmantot ticamības intervālu. Ticmības intervāla interpretē tā, ka izveiddojot daudzas jaunas paraugkopas un aprēķinot tām ticamības intervālu, tiacamības līmenim atbilstošo reižu gadījumā šajā intervālā atradīsies konkrētais ģenerālkopas rādītājs, kas tiek novērtēts. Ticamības intervālu var aprēķināt ne tikai ģenerālkopu raksturojošiem rādītājiem kā vidējais aritmētiskais un standartnovirze, bet arī jebkuram citam rādītājām, piemēram, korelācijas koeficientam starp divām paraugkopām.  6.2.1.1 Vidējā aritmētiskā ticamības intervāls Vidējā aritmētiskā ticamības intervāla aprēķināšanai ir vairākas formulas, kuras atšķiras pēc tā, vai ir zināma vai nav zināma ģenerālkopas standartnovirze. Tā kā vairumā gadījumu tā nav zināma, tad izmantota formula intervāla aprēķināšanai izmantojot tikai paraugkopas datus. Šai formulai pieņēmums ir, ka paraugkopas dati ir nākuši no ģenerālkopas, kas seko normālajam sadalījumam. Ticamības intervālam aprēķina augšējo un apakšējo robežu pēc formulas (\\ref{eq:ticvid}). Stjūdenta kritērija teorētisko vērtību pie atbilstošā būtiskuma līmeņa var atrast speciālās statistiskas tabulās, vai arī aprēķināt. \\begin{equation} \\overline{x}-t_{\\alpha/2,\\nu} \\cdot s_{\\overline{x}} &lt; \\mu &lt; \\overline{x}+t_{\\alpha/2,\\nu} \\cdot s_{\\overline{x}} \\label{eq:ticvid} \\end{equation} kur \\(\\overline{x}\\) - vidējais aritmētiskais \\(t_{\\alpha/2,\\nu}\\) – Stjūdenta kritērija teorētiskā vērtība \\(\\nu= n-1\\) – brīvības pakāpju skaits \\(s_{\\overline{x}}\\) – vidējā aritmētiskā reprezentācijas rādītājs \\(s_{\\overline{x}}=\\frac{s}{\\sqrt{n}}\\) \\(\\mu\\) - ģenerālkopas vidējais aritmētiskais. Vidējā aritmētiskā reprezentācijas rādītāju sauc arī par vidējā aritmētiskā standartkļūdu, un tas parāda, cik precīzi paraugkopas dati raksturo ģenerālkopas datus.    6.2.2 Ticamības intervālu aprēķināšana Vidējā aritmētiskā ticamības intervālu var aprēķināt gan izmantojot gatavas funkcijas, gan arī izmantojot aprēķina formulas. Stjūdenta kritērija teorētisko vērtību aprēķina ar funkciju qt(), kurai kā pirmais arguments jānorāda \\((1-\\alpha/2)\\) (šoreiz izvēlamies strādāt pie ticamības līmeņa 99%) un otrais arguments ir brīvības pakāpju skaits (49). Vidējā aritmētiskā reprezentācijas rādītāju aprēķina kā standartnovirze dalīts ar kvadrātsakni no novērojumu skaita. Pēc tam ticamības intervāla augšējo un apakšējo robežu iegūst pieskaitot vai atņemot robežas vērtību no vidējā aritmētiskā. Piemēram izmantots niedru lapu garums. robeza&lt;-qt((1-0.01/2),49)*(sd(niedr$garums))/sqrt(50) augsa&lt;-mean(niedr$garums)+robeza apaksa&lt;-mean(niedr$garums)-robeza round(apaksa,2) ## [1] 33.69 round(augsa,2) ## [1] 41.5 Secinājums: 99% ticamības intervāls niedru lapu garuma vidējam aritmētiskajam ir ni 33,69 līdz 41,50 cm. Ticamības intervālu vidējām aritmētiskajam var aprēķināt arī ar funkciju t.test(), kurai kā argumentus norāda kolonnu/vektoru, kuram jāaprēķina ticamības intervāls, kā arī vēlamais ticamības līmenis (conf.level=). Funkcijas rezultātu ir vēlams saglabāt kā atsevišķu objektu. Ar funkciju names() apskatot objekta struktūru nosaukumus, var redzēt, ka ir atsevišķs objekts ar nosaukumu conf.int. To var atlasīt izmantojot $ zīmi. Iegūtais rezultāts ir identisks tam, kuru ieguva izmantojot formulas. tests&lt;-t.test(niedr$garums,conf.level=0.99) names(tests) ## [1] &quot;statistic&quot;   &quot;parameter&quot;   &quot;p.value&quot;     &quot;conf.int&quot;    &quot;estimate&quot;    ## [6] &quot;null.value&quot;  &quot;alternative&quot; &quot;method&quot;      &quot;data.name&quot; round(tests$conf.int,2) ## [1] 33.69 41.50 ## attr(,&quot;conf.level&quot;) ## [1] 0.99   6.2.3 Bootstrap ticamības intervāli Atsevišķos gadījumos ticamības intervālus nepieciešams aprēķināt rādītājiem, kuriem nav izstrādātā formula, vai arī zināmiem rādītājiem nevar izmantot parastos aprēķina veidus, jo tiek pārkāpti kādi pieņēmumi par datiem, piemēram, to homogenitāti. Šādos gadījumos var izmantot tā saukto bootstrap metodi. Metodes pamātā ir tas, ka no esošajiem datiem veido daudzas jaunas paraugkopas, kuru apjoms ir vienāds ar oriģinālajiem datiem. Jaunu paraugkopu veidošana notiek pēc paraugošanas ar aizvietošanu principa, tas ir, katra no oriģinālajām vērtībām var tik izraudzīta vairāk kā vienu reizi. Pēc tam katrai no jaunajām paraugkopām aprēķina interesējošo rādītāju un tad aprēķina ticamības intervālu, piemēram, balstoties uz procentilēm. Lai izmantotu bootstrap metodi programmā R, ir izveidota tam īpaši paredzēta pakete boot (Canty and Ripley 2012). Piemērā aprēķināts ticamības intervāls tiem pašiem niedru lapu garumiem. Sākumā ar funkcijuset.seed() tiek panākts, lai rezultāts būtu identisks piemēram. Tālāk ir jānodefinē funkcija, kas aprēķina vēlamo rādītāju. Šo funkciju nosaucam par videjie un tai būs divi mainīgie - data un indices, kuru radīs funkcija boot(). indices norādīs indeksus, lai atlasītu skaitļus no mainīgā data. Jaunie skaitļi tiks saglabāti mainīgajā d un šim mainīgajam aprēķinās vidējo aritmētisko. Tālāk izmanto funkciju boot(), kurai kā argumentus norādā oriģinālo skaitļu rindu/kolonnu, aprēķināmo rādītāju (funkcija videjie), kā arī veidojamo paraugu skaitu (šoreiz 1000). set.seed(1234) library(boot) videjie&lt;-function(data,indices){    d&lt;-data[indices]    mean(d)  } dat&lt;-boot(data=niedr$garums,statistic=videjie,R=1000) Ar funkciju boot() izveidoto objektu var apskatīt arī grafiski (6.1 attēls) - redzams, ka iegūtie vidējie aritmētiskie apmēram veido normālo sadalījumu plot(dat)    Figure 6.1: Bootstrap vidējo aritmētisko histogramma un QQ grafik   Bootstrap ticamības intervālu aprēķināšanai izmanto funkciju boot.ci(), kurai kā argumentus norāda boot() izveidoto objektu, kā arī vēlamo ticamības līmeni (conf=). Funkcija aprēķina vairākus ticamības intervāla veidus (Manly 2007), kas dod samērā līdzīgus rezultātus. boot.ci(dat,conf=0.99) ## Warning in boot.ci(dat, conf = 0.99): bootstrap variances needed for ## studentized intervals ## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS ## Based on 1000 bootstrap replicates ##  ## CALL :  ## boot.ci(boot.out = dat, conf = 0.99) ##  ## Intervals :  ## Level      Normal              Basic          ## 99%   (34.04, 41.09 )   (33.86, 41.62 )   ##  ## Level     Percentile            BCa           ## 99%   (33.56, 41.33 )   (33.39, 41.11 )   ## Calculations and Intervals on Original Scale ## Some basic intervals may be unstable ## Some percentile intervals may be unstable ## Some BCa intervals may be unstable   6.2.4 Ticamības intervālu grafiskais attēlojums Izmantojot funkcijas, kas pieejamas paketē plotrix (Lemon 2006), ir iespējams izveidot grafiku ar ticamības intervāliem. Pirmkārt, ir nepieciešams objekts, kas satur vidējos aritmētiskos. Piemēram izmantots niedru lapu garums, kas aprēķināts katram no parauglaukumiem. videjie&lt;-tapply(niedr$garums,niedr$paraug,mean) videjie ##    Austr     Riet     Ziem  ## 33.52941 41.05294 38.23750 Pēc tam jāizveido objekts, kas satur skaitļus Stjūdenta kritērija un videjā aritmētiskā reprezentācijas rādītāja reizinājumus. Tam izmanto atkal funkciju tapply(), tikai beigās norāda paša definētu funkciju. vid.rob&lt;-tapply(niedr$garums,niedr$paraug,   function(x) (qt((1-0.01/2),length(x))*sd(x)/sqrt(length(x)))) vid.rob ##    Austr     Riet     Ziem  ## 6.234850 6.590739 8.547961 Grafika ar ticāmības intervāliem izveidošanai (6.2 attēls) jāizmanto funkcija plotCI(), kurai kā argumentus jānorāda x mainīgais (šoreiz skaitļi no 1 līdz 3, jo ir trīs parauglaukumi), pēc tam jānorāda vektors ar vidējiem aritmētiskajiem, vektors ar Stjūdenta kritērija un videjā aritmētiskā reprezentācijas rādītāja reizinājumiem, kā arī var norādīt papildus argumentus grafika izskata uzlabošanai. library(plotrix) plotCI(1:3,as.vector(videjie),as.vector(vid.rob),axes=F,xlab=&quot;Puse&quot;,ylab=&quot;Videjais garums&quot;,ylim=c(0,50),lwd=2) axis(1,at=1:3,labels=c(&quot;A&quot;,&quot;R&quot;,&quot;Z&quot;)) axis(2,at=seq(0,50,10)) box()    Figure 6.2: Vidējais niedru lapu garums trīs parauglaukumos ar 99% ticamības intervāliem      "],
["literatura.html", "7. nodaļa. Literatūra", " 7. nodaļa. Literatūra    Arhipova, I., and S. Bāliņa. 2006. Statistika Ekonomikā. Risinājumi Ar SPSS Un Microsoft Excel. Datorzinību Centrs.   Canty, A., and B. Ripley. 2012. Boot: Bootstrap R (S-Plus) Functions. R Package Version 1.3-5.   Crawley, M.J. 2007. The R Book. Wiley.   Everitt, B., and T. Hothorn. 2006. A Handbook of Statistical Analyses Using R. CRC Press.   Johnson, D.H. 1999. “The Insignificance of Statistical Significance Testing.” Journal of Wildlife Management 63 (3): 763–72.   Lemon, J. 2006. “Plotrix: A Package in the Red Light District of R.” R-News 6 (4): 8–12.   Liepa, Imants. 1974. Biometrija. Zvaigzne.   Maindonald, J., and W.J. Braun. 2010. Data Analysis and Graphics Using R. An Example-Based Approach. Cambridge.   Manly, B.F.J. 2007. Randomization, Bootstrap and Monte Carlo Methods in Biology. Chapman, Hall/CRC.   Murrell, P. 2006. R Graphics. CRC Press.   R Core Team. 2012. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. http://www.R-project.org/.   Sarkar, D. 2008. Lattice. Multivariate Data Visualization with R. Springer.   Sokal, R.R., and F.J. Rohlf. 1995. Biometry. W.H. Freeman; company.   Stephens, P.A., S.W. Buskirk, G.D. Hayward, and C.M. Del Rio. 2005. “Information Theory and Hypothesis Testing: A Call for Pluralism.” Journal of Applied Ecology 42: 4–12.   Verzani, J. 2005. Using R for Introductory Statistics. Chapman; Hall/CRC.   Wicham, H. 2009. Ggplot2. Elegant Graphics for Data Analysis. Springer.   Zuur, A.F., E.N. Ieno, and G.M. Smith. 2007. Analysing Ecological Data. Springer.   "]
]
